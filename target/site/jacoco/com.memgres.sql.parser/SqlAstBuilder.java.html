<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SqlAstBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">MemGres Core</a> &gt; <a href="index.source.html" class="el_package">com.memgres.sql.parser</a> &gt; <span class="el_source">SqlAstBuilder.java</span></div><h1>SqlAstBuilder.java</h1><pre class="source lang-java linenums">package com.memgres.sql.parser;

import com.memgres.sql.PostgreSQLParser;
import com.memgres.sql.PostgreSQLParserBaseVisitor;
import com.memgres.sql.ast.expression.*;
import com.memgres.sql.ast.statement.*;
import com.memgres.types.DataType;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Visitor that converts ANTLR4 parse trees into our SQL AST nodes.
 */
<span class="fc" id="L15">public class SqlAstBuilder extends PostgreSQLParserBaseVisitor&lt;Object&gt; {</span>
    
    /**
     * Visit the top-level SQL context and return a list of statements.
     */
    public List&lt;Statement&gt; visit(PostgreSQLParser.SqlContext ctx) {
<span class="fc" id="L21">        List&lt;Statement&gt; statements = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L22" title="All 2 branches covered.">        for (PostgreSQLParser.StatementContext stmtCtx : ctx.statement()) {</span>
<span class="fc" id="L23">            Statement stmt = (Statement) visit(stmtCtx);</span>
<span class="pc bpc" id="L24" title="1 of 2 branches missed.">            if (stmt != null) {</span>
<span class="fc" id="L25">                statements.add(stmt);</span>
            }
<span class="fc" id="L27">        }</span>
<span class="fc" id="L28">        return statements;</span>
    }
    
    @Override
    public Statement visitStatement(PostgreSQLParser.StatementContext ctx) {
<span class="fc bfc" id="L33" title="All 2 branches covered.">        if (ctx.selectStatement() != null) {</span>
<span class="fc" id="L34">            return (Statement) visit(ctx.selectStatement());</span>
<span class="fc bfc" id="L35" title="All 2 branches covered.">        } else if (ctx.insertStatement() != null) {</span>
<span class="fc" id="L36">            return (Statement) visit(ctx.insertStatement());</span>
<span class="fc bfc" id="L37" title="All 2 branches covered.">        } else if (ctx.updateStatement() != null) {</span>
<span class="fc" id="L38">            return (Statement) visit(ctx.updateStatement());</span>
<span class="fc bfc" id="L39" title="All 2 branches covered.">        } else if (ctx.deleteStatement() != null) {</span>
<span class="fc" id="L40">            return (Statement) visit(ctx.deleteStatement());</span>
<span class="pc bpc" id="L41" title="1 of 2 branches missed.">        } else if (ctx.createTableStatement() != null) {</span>
<span class="fc" id="L42">            return (Statement) visit(ctx.createTableStatement());</span>
<span class="nc bnc" id="L43" title="All 2 branches missed.">        } else if (ctx.dropTableStatement() != null) {</span>
<span class="nc" id="L44">            return (Statement) visit(ctx.dropTableStatement());</span>
        }
<span class="nc" id="L46">        return null;</span>
    }
    
    @Override
    public SelectStatement visitSelectStatement(PostgreSQLParser.SelectStatementContext ctx) {
        // Parse DISTINCT
<span class="pc bpc" id="L52" title="1 of 2 branches missed.">        boolean distinct = ctx.selectModifier() != null &amp;&amp; </span>
<span class="pc bnc" id="L53" title="All 2 branches missed.">                          ctx.selectModifier().DISTINCT() != null;</span>
        
        // Parse SELECT list
<span class="fc" id="L56">        List&lt;SelectItem&gt; selectItems = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L57" title="All 2 branches covered.">        if (ctx.selectList().MULTIPLY() != null) {</span>
<span class="fc" id="L58">            selectItems.add(new SelectItem()); // Wildcard</span>
        } else {
<span class="fc bfc" id="L60" title="All 2 branches covered.">            for (PostgreSQLParser.SelectItemContext itemCtx : ctx.selectList().selectItem()) {</span>
<span class="fc" id="L61">                selectItems.add((SelectItem) visit(itemCtx));</span>
<span class="fc" id="L62">            }</span>
        }
        
        // Parse FROM clause (optional for subqueries)
<span class="fc bfc" id="L66" title="All 2 branches covered.">        Optional&lt;FromClause&gt; fromClause = ctx.fromClause() != null ?</span>
<span class="fc" id="L67">            Optional.of((FromClause) visit(ctx.fromClause())) : Optional.empty();</span>
        
        // Parse optional clauses
<span class="fc bfc" id="L70" title="All 2 branches covered.">        Optional&lt;WhereClause&gt; whereClause = ctx.whereClause() != null ? </span>
<span class="fc" id="L71">            Optional.of((WhereClause) visit(ctx.whereClause())) : Optional.empty();</span>
            
<span class="fc bfc" id="L73" title="All 2 branches covered.">        Optional&lt;GroupByClause&gt; groupByClause = ctx.groupByClause() != null ?</span>
<span class="fc" id="L74">            Optional.of((GroupByClause) visit(ctx.groupByClause())) : Optional.empty();</span>
            
<span class="pc bpc" id="L76" title="1 of 2 branches missed.">        Optional&lt;HavingClause&gt; havingClause = ctx.havingClause() != null ?</span>
<span class="pc" id="L77">            Optional.of((HavingClause) visit(ctx.havingClause())) : Optional.empty();</span>
            
<span class="fc bfc" id="L79" title="All 2 branches covered.">        Optional&lt;OrderByClause&gt; orderByClause = ctx.orderByClause() != null ?</span>
<span class="fc" id="L80">            Optional.of((OrderByClause) visit(ctx.orderByClause())) : Optional.empty();</span>
            
<span class="fc bfc" id="L82" title="All 2 branches covered.">        Optional&lt;LimitClause&gt; limitClause = ctx.limitClause() != null ?</span>
<span class="fc" id="L83">            Optional.of((LimitClause) visit(ctx.limitClause())) : Optional.empty();</span>
        
<span class="fc" id="L85">        return new SelectStatement(distinct, selectItems, fromClause, whereClause,</span>
                                 groupByClause, havingClause, orderByClause, limitClause);
    }
    
    @Override
    public SelectItem visitSelectItem(PostgreSQLParser.SelectItemContext ctx) {
<span class="fc" id="L91">        Expression expression = (Expression) visit(ctx.expression());</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">        Optional&lt;String&gt; alias = ctx.alias() != null ? </span>
<span class="fc" id="L93">            Optional.of(ctx.alias().getText()) : Optional.empty();</span>
<span class="fc" id="L94">        return new SelectItem(expression, alias);</span>
    }
    
    @Override
    public FromClause visitFromClause(PostgreSQLParser.FromClauseContext ctx) {
<span class="fc" id="L99">        List&lt;JoinableTable&gt; joinableTables = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">        for (PostgreSQLParser.JoinableTableContext joinableCtx : ctx.joinableTable()) {</span>
<span class="fc" id="L101">            joinableTables.add((JoinableTable) visit(joinableCtx));</span>
<span class="fc" id="L102">        }</span>
<span class="fc" id="L103">        return new FromClause(joinableTables);</span>
    }
    
    @Override
    public JoinableTable visitJoinableTable(PostgreSQLParser.JoinableTableContext ctx) {
        // Get the base table reference
<span class="fc" id="L109">        TableReference baseTable = (TableReference) visit(ctx.tableReference());</span>
        
        // Get all join clauses
<span class="fc" id="L112">        List&lt;JoinClause&gt; joins = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">        for (PostgreSQLParser.JoinClauseContext joinCtx : ctx.joinClause()) {</span>
<span class="fc" id="L114">            joins.add((JoinClause) visit(joinCtx));</span>
<span class="fc" id="L115">        }</span>
        
<span class="fc" id="L117">        return new JoinableTable(baseTable, joins);</span>
    }
    
    @Override
    public JoinClause visitJoinClause(PostgreSQLParser.JoinClauseContext ctx) {
        // Get join type
<span class="fc" id="L123">        JoinClause.JoinType joinType = getJoinType(ctx.joinType());</span>
        
        // Get the table being joined
<span class="fc" id="L126">        TableReference table = (TableReference) visit(ctx.tableReference());</span>
        
        // Get join condition
<span class="fc" id="L129">        Optional&lt;Expression&gt; onCondition = Optional.empty();</span>
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">        if (ctx.joinCondition() != null) {</span>
<span class="fc" id="L131">            PostgreSQLParser.JoinConditionContext condCtx = ctx.joinCondition();</span>
            // Check if it's an ON condition (onJoinCondition alternative)
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">            if (condCtx instanceof PostgreSQLParser.OnJoinConditionContext) {</span>
<span class="fc" id="L134">                PostgreSQLParser.OnJoinConditionContext onCtx = (PostgreSQLParser.OnJoinConditionContext) condCtx;</span>
<span class="fc" id="L135">                Expression condition = (Expression) visit(onCtx.expression());</span>
<span class="fc" id="L136">                onCondition = Optional.of(condition);</span>
            }
            // TODO: Implement USING and NATURAL joins
        }
        // Note: USING and NATURAL joins are not implemented yet
        
<span class="fc" id="L142">        return new JoinClause(joinType, table, onCondition);</span>
    }
    
    /**
     * Convert ANTLR join type context to JoinClause.JoinType enum.
     */
    private JoinClause.JoinType getJoinType(PostgreSQLParser.JoinTypeContext ctx) {
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">        if (ctx == null) {</span>
<span class="nc" id="L150">            return JoinClause.JoinType.INNER; // Default to INNER JOIN</span>
        }
        
<span class="fc bfc" id="L153" title="All 2 branches covered.">        if (ctx instanceof PostgreSQLParser.InnerJoinContext) {</span>
<span class="fc" id="L154">            return JoinClause.JoinType.INNER;</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">        } else if (ctx instanceof PostgreSQLParser.LeftJoinContext) {</span>
<span class="fc" id="L156">            return JoinClause.JoinType.LEFT;</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">        } else if (ctx instanceof PostgreSQLParser.RightJoinContext) {</span>
<span class="fc" id="L158">            return JoinClause.JoinType.RIGHT;</span>
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">        } else if (ctx instanceof PostgreSQLParser.FullOuterJoinContext) {</span>
<span class="fc" id="L160">            return JoinClause.JoinType.FULL_OUTER;</span>
        } else {
<span class="nc" id="L162">            return JoinClause.JoinType.INNER; // Default fallback</span>
        }
    }
    
    @Override
    public TableReference visitTableReference(PostgreSQLParser.TableReferenceContext ctx) {
<span class="fc" id="L168">        String tableName = ctx.tableName().getText();</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">        Optional&lt;String&gt; alias = ctx.alias() != null ? </span>
<span class="fc" id="L170">            Optional.of(ctx.alias().getText()) : Optional.empty();</span>
<span class="fc" id="L171">        return new TableReference(tableName, alias);</span>
    }
    
    @Override
    public WhereClause visitWhereClause(PostgreSQLParser.WhereClauseContext ctx) {
<span class="fc" id="L176">        Expression condition = (Expression) visit(ctx.expression());</span>
<span class="fc" id="L177">        return new WhereClause(condition);</span>
    }
    
    @Override
    public OrderByClause visitOrderByClause(PostgreSQLParser.OrderByClauseContext ctx) {
<span class="fc" id="L182">        List&lt;OrderByClause.OrderItem&gt; items = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">        for (PostgreSQLParser.OrderItemContext itemCtx : ctx.orderItem()) {</span>
<span class="fc" id="L184">            Expression expr = (Expression) visit(itemCtx.expression());</span>
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">            boolean ascending = itemCtx.DESC() == null; // Default to ASC</span>
<span class="fc" id="L186">            items.add(new OrderByClause.OrderItem(expr, ascending));</span>
<span class="fc" id="L187">        }</span>
<span class="fc" id="L188">        return new OrderByClause(items);</span>
    }
    
    @Override
    public GroupByClause visitGroupByClause(PostgreSQLParser.GroupByClauseContext ctx) {
<span class="fc" id="L193">        List&lt;Expression&gt; expressions = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">        for (PostgreSQLParser.ExpressionContext exprCtx : ctx.expression()) {</span>
<span class="fc" id="L195">            expressions.add((Expression) visit(exprCtx));</span>
<span class="fc" id="L196">        }</span>
<span class="fc" id="L197">        return new GroupByClause(expressions);</span>
    }
    
    @Override
    public HavingClause visitHavingClause(PostgreSQLParser.HavingClauseContext ctx) {
<span class="nc" id="L202">        Expression condition = (Expression) visit(ctx.expression());</span>
<span class="nc" id="L203">        return new HavingClause(condition);</span>
    }
    
    @Override
    public LimitClause visitLimitClause(PostgreSQLParser.LimitClauseContext ctx) {
<span class="fc" id="L208">        Expression limit = (Expression) visit(ctx.expression(0));</span>
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">        Optional&lt;Expression&gt; offset = ctx.expression().size() &gt; 1 ?</span>
<span class="pc" id="L210">            Optional.of((Expression) visit(ctx.expression(1))) : Optional.empty();</span>
<span class="fc" id="L211">        return new LimitClause(limit, offset);</span>
    }
    
    // Expression visitors
    @Override
    public Expression visitLiteralExpression(PostgreSQLParser.LiteralExpressionContext ctx) {
<span class="fc" id="L217">        return (Expression) visit(ctx.literal());</span>
    }
    
    @Override
    public LiteralExpression visitStringLiteral(PostgreSQLParser.StringLiteralContext ctx) {
<span class="fc" id="L222">        String text = ctx.STRING().getText();</span>
        // Remove quotes
<span class="fc" id="L224">        String value = text.substring(1, text.length() - 1);</span>
<span class="fc" id="L225">        return new LiteralExpression(value, LiteralExpression.LiteralType.STRING);</span>
    }
    
    @Override
    public LiteralExpression visitIntegerLiteral(PostgreSQLParser.IntegerLiteralContext ctx) {
<span class="fc" id="L230">        Long value = Long.parseLong(ctx.INTEGER_LITERAL().getText());</span>
<span class="fc" id="L231">        return new LiteralExpression(value, LiteralExpression.LiteralType.INTEGER);</span>
    }
    
    @Override
    public LiteralExpression visitDecimalLiteral(PostgreSQLParser.DecimalLiteralContext ctx) {
<span class="nc" id="L236">        Double value = Double.parseDouble(ctx.DECIMAL_LITERAL().getText());</span>
<span class="nc" id="L237">        return new LiteralExpression(value, LiteralExpression.LiteralType.DECIMAL);</span>
    }
    
    @Override
    public LiteralExpression visitBooleanLiteral(PostgreSQLParser.BooleanLiteralContext ctx) {
<span class="fc bfc" id="L242" title="All 2 branches covered.">        Boolean value = ctx.TRUE() != null;</span>
<span class="fc" id="L243">        return new LiteralExpression(value, LiteralExpression.LiteralType.BOOLEAN);</span>
    }
    
    @Override
    public LiteralExpression visitNullLiteral(PostgreSQLParser.NullLiteralContext ctx) {
<span class="nc" id="L248">        return new LiteralExpression(null, LiteralExpression.LiteralType.NULL);</span>
    }
    
    @Override
    public Expression visitColumnReferenceExpression(PostgreSQLParser.ColumnReferenceExpressionContext ctx) {
<span class="fc" id="L253">        return (Expression) visit(ctx.columnReference());</span>
    }
    
    @Override
    public ColumnReference visitColumnReference(PostgreSQLParser.ColumnReferenceContext ctx) {
<span class="fc bfc" id="L258" title="All 2 branches covered.">        if (ctx.tableName() != null) {</span>
<span class="fc" id="L259">            String tableName = ctx.tableName().getText();</span>
<span class="fc" id="L260">            String columnName = ctx.columnName().getText();</span>
<span class="fc" id="L261">            return new ColumnReference(tableName, columnName);</span>
        } else {
<span class="fc" id="L263">            String columnName = ctx.columnName().getText();</span>
<span class="fc" id="L264">            return new ColumnReference(columnName);</span>
        }
    }
    
    @Override
    public Expression visitBinaryExpression(PostgreSQLParser.BinaryExpressionContext ctx) {
<span class="fc" id="L270">        Expression left = (Expression) visit(ctx.expression(0));</span>
<span class="fc" id="L271">        Expression right = (Expression) visit(ctx.expression(1));</span>
<span class="fc" id="L272">        BinaryExpression.Operator operator = getBinaryOperator(ctx.binaryOperator());</span>
<span class="fc" id="L273">        return new BinaryExpression(left, operator, right);</span>
    }
    
    @Override
    public Expression visitFunctionCallExpression(PostgreSQLParser.FunctionCallExpressionContext ctx) {
<span class="fc" id="L278">        return (Expression) visit(ctx.functionCall());</span>
    }
    
    @Override
    public FunctionCall visitGenRandomUuidFunction(PostgreSQLParser.GenRandomUuidFunctionContext ctx) {
<span class="fc" id="L283">        return new FunctionCall(&quot;gen_random_uuid&quot;, List.of());</span>
    }
    
    @Override
    public FunctionCall visitUuidGenerateV1Function(PostgreSQLParser.UuidGenerateV1FunctionContext ctx) {
<span class="nc" id="L288">        return new FunctionCall(&quot;uuid_generate_v1&quot;, List.of());</span>
    }
    
    @Override
    public FunctionCall visitUuidGenerateV4Function(PostgreSQLParser.UuidGenerateV4FunctionContext ctx) {
<span class="nc" id="L293">        return new FunctionCall(&quot;uuid_generate_v4&quot;, List.of());</span>
    }
    
    @Override
    public FunctionCall visitGenericFunction(PostgreSQLParser.GenericFunctionContext ctx) {
<span class="nc" id="L298">        String functionName = ctx.identifier().getText();</span>
<span class="nc" id="L299">        List&lt;Expression&gt; arguments = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">        if (ctx.expressionList() != null) {</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">            for (PostgreSQLParser.ExpressionContext exprCtx : ctx.expressionList().expression()) {</span>
<span class="nc" id="L302">                arguments.add((Expression) visit(exprCtx));</span>
<span class="nc" id="L303">            }</span>
        }
<span class="nc" id="L305">        return new FunctionCall(functionName, arguments);</span>
    }
    
    @Override
    public SubqueryExpression visitSubqueryExpression(PostgreSQLParser.SubqueryExpressionContext ctx) {
<span class="fc" id="L310">        SelectStatement selectStatement = (SelectStatement) visit(ctx.selectStatement());</span>
<span class="fc" id="L311">        return new SubqueryExpression(selectStatement);</span>
    }
    
    @Override
    public ExistsExpression visitExistsExpression(PostgreSQLParser.ExistsExpressionContext ctx) {
<span class="fc" id="L316">        SelectStatement subquery = (SelectStatement) visit(ctx.selectStatement());</span>
<span class="fc" id="L317">        return new ExistsExpression(subquery);</span>
    }
    
    @Override
    public InSubqueryExpression visitInSubqueryExpression(PostgreSQLParser.InSubqueryExpressionContext ctx) {
<span class="fc" id="L322">        Expression expression = (Expression) visit(ctx.expression());</span>
<span class="fc" id="L323">        SelectStatement subquery = (SelectStatement) visit(ctx.selectStatement());</span>
<span class="fc bfc" id="L324" title="All 2 branches covered.">        boolean negated = ctx.NOT() != null;</span>
<span class="fc" id="L325">        return new InSubqueryExpression(expression, subquery, negated);</span>
    }
    
    @Override
    public AggregateFunction visitCountFunction(PostgreSQLParser.CountFunctionContext ctx) {
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">        if (ctx.MULTIPLY() != null) {</span>
            // COUNT(*)
<span class="fc" id="L332">            return new AggregateFunction(AggregateFunction.AggregateType.COUNT, null);</span>
        } else {
            // COUNT(expression)
<span class="nc" id="L335">            Expression expr = (Expression) visit(ctx.expression());</span>
<span class="nc" id="L336">            return new AggregateFunction(AggregateFunction.AggregateType.COUNT, expr);</span>
        }
    }
    
    @Override
    public AggregateFunction visitSumFunction(PostgreSQLParser.SumFunctionContext ctx) {
<span class="fc" id="L342">        Expression expr = (Expression) visit(ctx.expression());</span>
<span class="fc" id="L343">        return new AggregateFunction(AggregateFunction.AggregateType.SUM, expr);</span>
    }
    
    @Override
    public AggregateFunction visitAvgFunction(PostgreSQLParser.AvgFunctionContext ctx) {
<span class="fc" id="L348">        Expression expr = (Expression) visit(ctx.expression());</span>
<span class="fc" id="L349">        return new AggregateFunction(AggregateFunction.AggregateType.AVG, expr);</span>
    }
    
    @Override
    public AggregateFunction visitMinFunction(PostgreSQLParser.MinFunctionContext ctx) {
<span class="fc" id="L354">        Expression expr = (Expression) visit(ctx.expression());</span>
<span class="fc" id="L355">        return new AggregateFunction(AggregateFunction.AggregateType.MIN, expr);</span>
    }
    
    @Override
    public AggregateFunction visitMaxFunction(PostgreSQLParser.MaxFunctionContext ctx) {
<span class="fc" id="L360">        Expression expr = (Expression) visit(ctx.expression());</span>
<span class="fc" id="L361">        return new AggregateFunction(AggregateFunction.AggregateType.MAX, expr);</span>
    }
    
    @Override
    public AggregateFunction visitCountDistinctFunction(PostgreSQLParser.CountDistinctFunctionContext ctx) {
<span class="nc" id="L366">        Expression expr = (Expression) visit(ctx.expression());</span>
<span class="nc" id="L367">        return new AggregateFunction(AggregateFunction.AggregateType.COUNT_DISTINCT, expr);</span>
    }
    
    // INSERT statement
    @Override
    public InsertStatement visitInsertStatement(PostgreSQLParser.InsertStatementContext ctx) {
<span class="fc" id="L373">        String tableName = ctx.tableName().getText();</span>
        
<span class="fc" id="L375">        Optional&lt;List&lt;String&gt;&gt; columns = Optional.empty();</span>
<span class="pc bpc" id="L376" title="1 of 2 branches missed.">        if (ctx.columnList() != null) {</span>
<span class="nc" id="L377">            List&lt;String&gt; columnNames = ctx.columnList().columnName().stream()</span>
<span class="nc" id="L378">                .map(c -&gt; c.getText())</span>
<span class="nc" id="L379">                .collect(Collectors.toList());</span>
<span class="nc" id="L380">            columns = Optional.of(columnNames);</span>
        }
        
<span class="fc" id="L383">        List&lt;List&lt;Expression&gt;&gt; valuesList = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">        for (PostgreSQLParser.ValuesClauseContext valuesCtx : ctx.valuesClause()) {</span>
<span class="fc" id="L385">            List&lt;Expression&gt; values = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">            for (PostgreSQLParser.ExpressionContext exprCtx : valuesCtx.expression()) {</span>
<span class="fc" id="L387">                values.add((Expression) visit(exprCtx));</span>
<span class="fc" id="L388">            }</span>
<span class="fc" id="L389">            valuesList.add(values);</span>
<span class="fc" id="L390">        }</span>
        
<span class="fc" id="L392">        return new InsertStatement(tableName, columns, valuesList);</span>
    }
    
    // UPDATE statement
    @Override
    public UpdateStatement visitUpdateStatement(PostgreSQLParser.UpdateStatementContext ctx) {
<span class="fc" id="L398">        String tableName = ctx.tableName().getText();</span>
        
<span class="fc" id="L400">        List&lt;UpdateStatement.UpdateItem&gt; updateItems = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">        for (PostgreSQLParser.UpdateItemContext updateCtx : ctx.updateItem()) {</span>
<span class="fc" id="L402">            String columnName = updateCtx.columnName().getText();</span>
<span class="fc" id="L403">            Expression value = (Expression) visit(updateCtx.expression());</span>
<span class="fc" id="L404">            updateItems.add(new UpdateStatement.UpdateItem(columnName, value));</span>
<span class="fc" id="L405">        }</span>
        
<span class="pc bpc" id="L407" title="1 of 2 branches missed.">        Optional&lt;WhereClause&gt; whereClause = ctx.whereClause() != null ? </span>
<span class="pc" id="L408">            Optional.of((WhereClause) visit(ctx.whereClause())) : Optional.empty();</span>
        
<span class="fc" id="L410">        return new UpdateStatement(tableName, updateItems, whereClause);</span>
    }
    
    // DELETE statement
    @Override
    public DeleteStatement visitDeleteStatement(PostgreSQLParser.DeleteStatementContext ctx) {
<span class="fc" id="L416">        String tableName = ctx.tableName().getText();</span>
        
<span class="pc bpc" id="L418" title="1 of 2 branches missed.">        Optional&lt;WhereClause&gt; whereClause = ctx.whereClause() != null ? </span>
<span class="pc" id="L419">            Optional.of((WhereClause) visit(ctx.whereClause())) : Optional.empty();</span>
        
<span class="fc" id="L421">        return new DeleteStatement(tableName, whereClause);</span>
    }
    
    // CREATE TABLE statement
    @Override
    public CreateTableStatement visitCreateTableStatement(PostgreSQLParser.CreateTableStatementContext ctx) {
<span class="fc" id="L427">        String tableName = ctx.tableName().getText();</span>
        
<span class="fc" id="L429">        List&lt;ColumnDefinition&gt; columnDefinitions = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">        for (PostgreSQLParser.ColumnDefinitionContext colCtx : ctx.columnDefinition()) {</span>
<span class="fc" id="L431">            String columnName = colCtx.columnName().getText();</span>
<span class="fc" id="L432">            DataTypeNode dataType = (DataTypeNode) visit(colCtx.dataType());</span>
            
<span class="fc" id="L434">            List&lt;ColumnDefinition.Constraint&gt; constraints = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L435" title="1 of 2 branches missed.">            if (colCtx.columnConstraint() != null) {</span>
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">                for (PostgreSQLParser.ColumnConstraintContext constraintCtx : colCtx.columnConstraint()) {</span>
<span class="nc bnc" id="L437" title="All 4 branches missed.">                    if (constraintCtx.NOT() != null &amp;&amp; constraintCtx.NULL() != null) {</span>
<span class="nc" id="L438">                        constraints.add(ColumnDefinition.Constraint.NOT_NULL);</span>
                    }
<span class="nc" id="L440">                }</span>
            }
            
<span class="fc" id="L443">            columnDefinitions.add(new ColumnDefinition(columnName, dataType, constraints));</span>
<span class="fc" id="L444">        }</span>
        
<span class="fc" id="L446">        return new CreateTableStatement(tableName, columnDefinitions);</span>
    }
    
    // DROP TABLE statement
    @Override
    public DropTableStatement visitDropTableStatement(PostgreSQLParser.DropTableStatementContext ctx) {
<span class="nc" id="L452">        String tableName = ctx.tableName().getText();</span>
<span class="nc" id="L453">        return new DropTableStatement(tableName);</span>
    }
    
    // Data type visitors
    @Override
    public DataTypeNode visitIntegerType(PostgreSQLParser.IntegerTypeContext ctx) {
<span class="fc" id="L459">        return new DataTypeNode(DataType.INTEGER);</span>
    }
    
    @Override
    public DataTypeNode visitBigintType(PostgreSQLParser.BigintTypeContext ctx) {
<span class="nc" id="L464">        return new DataTypeNode(DataType.BIGINT);</span>
    }
    
    @Override
    public DataTypeNode visitSmallintType(PostgreSQLParser.SmallintTypeContext ctx) {
<span class="nc" id="L469">        return new DataTypeNode(DataType.SMALLINT);</span>
    }
    
    @Override
    public DataTypeNode visitVarcharType(PostgreSQLParser.VarcharTypeContext ctx) {
<span class="fc" id="L474">        return new DataTypeNode(DataType.VARCHAR);</span>
    }
    
    @Override
    public DataTypeNode visitTextType(PostgreSQLParser.TextTypeContext ctx) {
<span class="nc" id="L479">        return new DataTypeNode(DataType.TEXT);</span>
    }
    
    @Override
    public DataTypeNode visitCharType(PostgreSQLParser.CharTypeContext ctx) {
<span class="nc" id="L484">        return new DataTypeNode(DataType.CHAR);</span>
    }
    
    @Override
    public DataTypeNode visitBooleanType(PostgreSQLParser.BooleanTypeContext ctx) {
<span class="fc" id="L489">        return new DataTypeNode(DataType.BOOLEAN);</span>
    }
    
    @Override
    public DataTypeNode visitUuidType(PostgreSQLParser.UuidTypeContext ctx) {
<span class="fc" id="L494">        return new DataTypeNode(DataType.UUID);</span>
    }
    
    @Override
    public DataTypeNode visitJsonbType(PostgreSQLParser.JsonbTypeContext ctx) {
<span class="nc" id="L499">        return new DataTypeNode(DataType.JSONB);</span>
    }
    
    @Override
    public DataTypeNode visitRealType(PostgreSQLParser.RealTypeContext ctx) {
<span class="nc" id="L504">        return new DataTypeNode(DataType.REAL);</span>
    }
    
    @Override
    public DataTypeNode visitDoublePrecisionType(PostgreSQLParser.DoublePrecisionTypeContext ctx) {
<span class="nc" id="L509">        return new DataTypeNode(DataType.DOUBLE_PRECISION);</span>
    }
    
    @Override
    public DataTypeNode visitDecimalType(PostgreSQLParser.DecimalTypeContext ctx) {
<span class="nc" id="L514">        return new DataTypeNode(DataType.DECIMAL);</span>
    }
    
    @Override
    public DataTypeNode visitNumericType(PostgreSQLParser.NumericTypeContext ctx) {
<span class="nc" id="L519">        return new DataTypeNode(DataType.DECIMAL);</span>
    }
    
    @Override
    public DataTypeNode visitDateType(PostgreSQLParser.DateTypeContext ctx) {
<span class="nc" id="L524">        return new DataTypeNode(DataType.DATE);</span>
    }
    
    @Override
    public DataTypeNode visitTimeType(PostgreSQLParser.TimeTypeContext ctx) {
<span class="nc" id="L529">        return new DataTypeNode(DataType.TIME);</span>
    }
    
    @Override
    public DataTypeNode visitTimestampType(PostgreSQLParser.TimestampTypeContext ctx) {
<span class="nc" id="L534">        return new DataTypeNode(DataType.TIMESTAMP);</span>
    }
    
    @Override
    public DataTypeNode visitTimestamptzType(PostgreSQLParser.TimestamptzTypeContext ctx) {
<span class="nc" id="L539">        return new DataTypeNode(DataType.TIMESTAMPTZ);</span>
    }
    
    @Override
    public DataTypeNode visitByteaType(PostgreSQLParser.ByteaTypeContext ctx) {
<span class="nc" id="L544">        return new DataTypeNode(DataType.BYTEA);</span>
    }
    
    /**
     * Convert ANTLR4 binary operator context to our BinaryExpression.Operator enum.
     */
    private BinaryExpression.Operator getBinaryOperator(PostgreSQLParser.BinaryOperatorContext ctx) {
<span class="fc bfc" id="L551" title="All 2 branches covered.">        if (ctx.EQ() != null) return BinaryExpression.Operator.EQUALS;</span>
<span class="pc bpc" id="L552" title="1 of 2 branches missed.">        if (ctx.NE() != null) return BinaryExpression.Operator.NOT_EQUALS;</span>
<span class="pc bpc" id="L553" title="1 of 2 branches missed.">        if (ctx.LT() != null) return BinaryExpression.Operator.LESS_THAN;</span>
<span class="pc bpc" id="L554" title="1 of 2 branches missed.">        if (ctx.LE() != null) return BinaryExpression.Operator.LESS_THAN_EQUALS;</span>
<span class="fc bfc" id="L555" title="All 2 branches covered.">        if (ctx.GT() != null) return BinaryExpression.Operator.GREATER_THAN;</span>
<span class="pc bpc" id="L556" title="1 of 2 branches missed.">        if (ctx.GE() != null) return BinaryExpression.Operator.GREATER_THAN_EQUALS;</span>
<span class="pc bpc" id="L557" title="1 of 2 branches missed.">        if (ctx.PLUS() != null) return BinaryExpression.Operator.ADD;</span>
<span class="pc bpc" id="L558" title="1 of 2 branches missed.">        if (ctx.MINUS() != null) return BinaryExpression.Operator.SUBTRACT;</span>
<span class="pc bpc" id="L559" title="1 of 2 branches missed.">        if (ctx.MULTIPLY() != null) return BinaryExpression.Operator.MULTIPLY;</span>
<span class="pc bpc" id="L560" title="1 of 2 branches missed.">        if (ctx.DIVIDE() != null) return BinaryExpression.Operator.DIVIDE;</span>
<span class="pc bpc" id="L561" title="1 of 2 branches missed.">        if (ctx.MODULO() != null) return BinaryExpression.Operator.MODULO;</span>
<span class="pc bpc" id="L562" title="1 of 2 branches missed.">        if (ctx.POWER() != null) return BinaryExpression.Operator.POWER;</span>
<span class="pc bpc" id="L563" title="1 of 2 branches missed.">        if (ctx.AND() != null) return BinaryExpression.Operator.AND;</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">        if (ctx.OR() != null) return BinaryExpression.Operator.OR;</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">        if (ctx.CONCAT() != null) return BinaryExpression.Operator.CONCAT;</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">        if (ctx.JSONB_CONTAINS() != null) return BinaryExpression.Operator.JSONB_CONTAINS;</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">        if (ctx.JSONB_CONTAINED() != null) return BinaryExpression.Operator.JSONB_CONTAINED;</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">        if (ctx.JSONB_EXISTS() != null) return BinaryExpression.Operator.JSONB_EXISTS;</span>
<span class="nc bnc" id="L569" title="All 2 branches missed.">        if (ctx.JSONB_EXTRACT() != null) return BinaryExpression.Operator.JSONB_EXTRACT;</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">        if (ctx.JSONB_EXTRACT_TEXT() != null) return BinaryExpression.Operator.JSONB_EXTRACT_TEXT;</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">        if (ctx.JSONB_PATH_EXTRACT() != null) return BinaryExpression.Operator.JSONB_PATH_EXTRACT;</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">        if (ctx.JSONB_PATH_EXTRACT_TEXT() != null) return BinaryExpression.Operator.JSONB_PATH_EXTRACT_TEXT;</span>
        
<span class="nc" id="L574">        throw new IllegalArgumentException(&quot;Unknown binary operator: &quot; + ctx.getText());</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>