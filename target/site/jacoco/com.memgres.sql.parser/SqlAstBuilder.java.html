<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SqlAstBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">MemGres Core</a> &gt; <a href="index.source.html" class="el_package">com.memgres.sql.parser</a> &gt; <span class="el_source">SqlAstBuilder.java</span></div><h1>SqlAstBuilder.java</h1><pre class="source lang-java linenums">package com.memgres.sql.parser;

import com.memgres.sql.PostgreSQLParser;
import com.memgres.sql.PostgreSQLParserBaseVisitor;
import com.memgres.sql.ast.expression.*;
import com.memgres.sql.ast.statement.*;
import com.memgres.types.DataType;

import java.math.BigDecimal;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Visitor that converts ANTLR4 parse trees into our SQL AST nodes.
 */
<span class="fc" id="L16">public class SqlAstBuilder extends PostgreSQLParserBaseVisitor&lt;Object&gt; {</span>
    
    /**
     * Visit the top-level SQL context and return a list of statements.
     */
    public List&lt;Statement&gt; visit(PostgreSQLParser.SqlContext ctx) {
<span class="fc" id="L22">        List&lt;Statement&gt; statements = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L23" title="All 2 branches covered.">        for (PostgreSQLParser.StatementContext stmtCtx : ctx.statement()) {</span>
<span class="fc" id="L24">            Statement stmt = (Statement) visit(stmtCtx);</span>
<span class="pc bpc" id="L25" title="1 of 2 branches missed.">            if (stmt != null) {</span>
<span class="fc" id="L26">                statements.add(stmt);</span>
            }
<span class="fc" id="L28">        }</span>
<span class="fc" id="L29">        return statements;</span>
    }
    
    @Override
    public Statement visitStatement(PostgreSQLParser.StatementContext ctx) {
<span class="fc bfc" id="L34" title="All 2 branches covered.">        if (ctx.selectStatement() != null) {</span>
<span class="fc" id="L35">            return (Statement) visit(ctx.selectStatement());</span>
<span class="fc bfc" id="L36" title="All 2 branches covered.">        } else if (ctx.insertStatement() != null) {</span>
<span class="fc" id="L37">            return (Statement) visit(ctx.insertStatement());</span>
<span class="fc bfc" id="L38" title="All 2 branches covered.">        } else if (ctx.updateStatement() != null) {</span>
<span class="fc" id="L39">            return (Statement) visit(ctx.updateStatement());</span>
<span class="fc bfc" id="L40" title="All 2 branches covered.">        } else if (ctx.deleteStatement() != null) {</span>
<span class="fc" id="L41">            return (Statement) visit(ctx.deleteStatement());</span>
<span class="pc bpc" id="L42" title="1 of 2 branches missed.">        } else if (ctx.createTableStatement() != null) {</span>
<span class="fc" id="L43">            return (Statement) visit(ctx.createTableStatement());</span>
<span class="nc bnc" id="L44" title="All 2 branches missed.">        } else if (ctx.dropTableStatement() != null) {</span>
<span class="nc" id="L45">            return (Statement) visit(ctx.dropTableStatement());</span>
        }
<span class="nc" id="L47">        return null;</span>
    }
    
    @Override
    public SelectStatement visitSelectStatement(PostgreSQLParser.SelectStatementContext ctx) {
        // Parse DISTINCT
<span class="pc bpc" id="L53" title="1 of 2 branches missed.">        boolean distinct = ctx.selectModifier() != null &amp;&amp; </span>
<span class="pc bnc" id="L54" title="All 2 branches missed.">                          ctx.selectModifier().DISTINCT() != null;</span>
        
        // Parse SELECT list
<span class="fc" id="L57">        List&lt;SelectItem&gt; selectItems = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L58" title="All 2 branches covered.">        if (ctx.selectList().MULTIPLY() != null) {</span>
<span class="fc" id="L59">            selectItems.add(new SelectItem()); // Wildcard</span>
        } else {
<span class="fc bfc" id="L61" title="All 2 branches covered.">            for (PostgreSQLParser.SelectItemContext itemCtx : ctx.selectList().selectItem()) {</span>
<span class="fc" id="L62">                selectItems.add((SelectItem) visit(itemCtx));</span>
<span class="fc" id="L63">            }</span>
        }
        
        // Parse FROM clause (optional for subqueries)
<span class="fc bfc" id="L67" title="All 2 branches covered.">        Optional&lt;FromClause&gt; fromClause = ctx.fromClause() != null ?</span>
<span class="fc" id="L68">            Optional.of((FromClause) visit(ctx.fromClause())) : Optional.empty();</span>
        
        // Parse optional clauses
<span class="fc bfc" id="L71" title="All 2 branches covered.">        Optional&lt;WhereClause&gt; whereClause = ctx.whereClause() != null ? </span>
<span class="fc" id="L72">            Optional.of((WhereClause) visit(ctx.whereClause())) : Optional.empty();</span>
            
<span class="fc bfc" id="L74" title="All 2 branches covered.">        Optional&lt;GroupByClause&gt; groupByClause = ctx.groupByClause() != null ?</span>
<span class="fc" id="L75">            Optional.of((GroupByClause) visit(ctx.groupByClause())) : Optional.empty();</span>
            
<span class="pc bpc" id="L77" title="1 of 2 branches missed.">        Optional&lt;HavingClause&gt; havingClause = ctx.havingClause() != null ?</span>
<span class="pc" id="L78">            Optional.of((HavingClause) visit(ctx.havingClause())) : Optional.empty();</span>
            
<span class="fc bfc" id="L80" title="All 2 branches covered.">        Optional&lt;OrderByClause&gt; orderByClause = ctx.orderByClause() != null ?</span>
<span class="fc" id="L81">            Optional.of((OrderByClause) visit(ctx.orderByClause())) : Optional.empty();</span>
            
<span class="fc bfc" id="L83" title="All 2 branches covered.">        Optional&lt;LimitClause&gt; limitClause = ctx.limitClause() != null ?</span>
<span class="fc" id="L84">            Optional.of((LimitClause) visit(ctx.limitClause())) : Optional.empty();</span>
        
<span class="fc" id="L86">        return new SelectStatement(distinct, selectItems, fromClause, whereClause,</span>
                                 groupByClause, havingClause, orderByClause, limitClause);
    }
    
    @Override
    public SelectItem visitSelectItem(PostgreSQLParser.SelectItemContext ctx) {
<span class="fc" id="L92">        Expression expression = (Expression) visit(ctx.expression());</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">        Optional&lt;String&gt; alias = ctx.alias() != null ? </span>
<span class="fc" id="L94">            Optional.of(ctx.alias().getText()) : Optional.empty();</span>
<span class="fc" id="L95">        return new SelectItem(expression, alias);</span>
    }
    
    @Override
    public FromClause visitFromClause(PostgreSQLParser.FromClauseContext ctx) {
<span class="fc" id="L100">        List&lt;JoinableTable&gt; joinableTables = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">        for (PostgreSQLParser.JoinableTableContext joinableCtx : ctx.joinableTable()) {</span>
<span class="fc" id="L102">            joinableTables.add((JoinableTable) visit(joinableCtx));</span>
<span class="fc" id="L103">        }</span>
<span class="fc" id="L104">        return new FromClause(joinableTables);</span>
    }
    
    @Override
    public JoinableTable visitJoinableTable(PostgreSQLParser.JoinableTableContext ctx) {
        // Get the base table reference
<span class="fc" id="L110">        TableReference baseTable = (TableReference) visit(ctx.tableReference());</span>
        
        // Get all join clauses
<span class="fc" id="L113">        List&lt;JoinClause&gt; joins = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">        for (PostgreSQLParser.JoinClauseContext joinCtx : ctx.joinClause()) {</span>
<span class="fc" id="L115">            joins.add((JoinClause) visit(joinCtx));</span>
<span class="fc" id="L116">        }</span>
        
<span class="fc" id="L118">        return new JoinableTable(baseTable, joins);</span>
    }
    
    @Override
    public JoinClause visitJoinClause(PostgreSQLParser.JoinClauseContext ctx) {
        // Get join type
<span class="fc" id="L124">        JoinClause.JoinType joinType = getJoinType(ctx.joinType());</span>
        
        // Get the table being joined
<span class="fc" id="L127">        TableReference table = (TableReference) visit(ctx.tableReference());</span>
        
        // Get join condition
<span class="fc" id="L130">        Optional&lt;Expression&gt; onCondition = Optional.empty();</span>
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">        if (ctx.joinCondition() != null) {</span>
<span class="fc" id="L132">            PostgreSQLParser.JoinConditionContext condCtx = ctx.joinCondition();</span>
            // Check if it's an ON condition (onJoinCondition alternative)
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">            if (condCtx instanceof PostgreSQLParser.OnJoinConditionContext) {</span>
<span class="fc" id="L135">                PostgreSQLParser.OnJoinConditionContext onCtx = (PostgreSQLParser.OnJoinConditionContext) condCtx;</span>
<span class="fc" id="L136">                Expression condition = (Expression) visit(onCtx.expression());</span>
<span class="fc" id="L137">                onCondition = Optional.of(condition);</span>
            }
            // TODO: Implement USING and NATURAL joins
        }
        // Note: USING and NATURAL joins are not implemented yet
        
<span class="fc" id="L143">        return new JoinClause(joinType, table, onCondition);</span>
    }
    
    /**
     * Convert ANTLR join type context to JoinClause.JoinType enum.
     */
    private JoinClause.JoinType getJoinType(PostgreSQLParser.JoinTypeContext ctx) {
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">        if (ctx == null) {</span>
<span class="nc" id="L151">            return JoinClause.JoinType.INNER; // Default to INNER JOIN</span>
        }
        
<span class="fc bfc" id="L154" title="All 2 branches covered.">        if (ctx instanceof PostgreSQLParser.InnerJoinContext) {</span>
<span class="fc" id="L155">            return JoinClause.JoinType.INNER;</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">        } else if (ctx instanceof PostgreSQLParser.LeftJoinContext) {</span>
<span class="fc" id="L157">            return JoinClause.JoinType.LEFT;</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">        } else if (ctx instanceof PostgreSQLParser.RightJoinContext) {</span>
<span class="fc" id="L159">            return JoinClause.JoinType.RIGHT;</span>
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">        } else if (ctx instanceof PostgreSQLParser.FullOuterJoinContext) {</span>
<span class="fc" id="L161">            return JoinClause.JoinType.FULL_OUTER;</span>
        } else {
<span class="nc" id="L163">            return JoinClause.JoinType.INNER; // Default fallback</span>
        }
    }
    
    @Override
    public TableReference visitTableReference(PostgreSQLParser.TableReferenceContext ctx) {
<span class="fc" id="L169">        String tableName = ctx.tableName().getText();</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">        Optional&lt;String&gt; alias = ctx.alias() != null ? </span>
<span class="fc" id="L171">            Optional.of(ctx.alias().getText()) : Optional.empty();</span>
<span class="fc" id="L172">        return new TableReference(tableName, alias);</span>
    }
    
    @Override
    public WhereClause visitWhereClause(PostgreSQLParser.WhereClauseContext ctx) {
<span class="fc" id="L177">        Expression condition = (Expression) visit(ctx.expression());</span>
<span class="fc" id="L178">        return new WhereClause(condition);</span>
    }
    
    @Override
    public OrderByClause visitOrderByClause(PostgreSQLParser.OrderByClauseContext ctx) {
<span class="fc" id="L183">        List&lt;OrderByClause.OrderItem&gt; items = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">        for (PostgreSQLParser.OrderItemContext itemCtx : ctx.orderItem()) {</span>
<span class="fc" id="L185">            Expression expr = (Expression) visit(itemCtx.expression());</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">            boolean ascending = itemCtx.DESC() == null; // Default to ASC</span>
<span class="fc" id="L187">            items.add(new OrderByClause.OrderItem(expr, ascending));</span>
<span class="fc" id="L188">        }</span>
<span class="fc" id="L189">        return new OrderByClause(items);</span>
    }
    
    @Override
    public GroupByClause visitGroupByClause(PostgreSQLParser.GroupByClauseContext ctx) {
<span class="fc" id="L194">        List&lt;Expression&gt; expressions = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">        for (PostgreSQLParser.ExpressionContext exprCtx : ctx.expression()) {</span>
<span class="fc" id="L196">            expressions.add((Expression) visit(exprCtx));</span>
<span class="fc" id="L197">        }</span>
<span class="fc" id="L198">        return new GroupByClause(expressions);</span>
    }
    
    @Override
    public HavingClause visitHavingClause(PostgreSQLParser.HavingClauseContext ctx) {
<span class="nc" id="L203">        Expression condition = (Expression) visit(ctx.expression());</span>
<span class="nc" id="L204">        return new HavingClause(condition);</span>
    }
    
    @Override
    public LimitClause visitLimitClause(PostgreSQLParser.LimitClauseContext ctx) {
<span class="fc" id="L209">        Expression limit = (Expression) visit(ctx.expression(0));</span>
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">        Optional&lt;Expression&gt; offset = ctx.expression().size() &gt; 1 ?</span>
<span class="pc" id="L211">            Optional.of((Expression) visit(ctx.expression(1))) : Optional.empty();</span>
<span class="fc" id="L212">        return new LimitClause(limit, offset);</span>
    }
    
    // Expression visitors
    @Override
    public Expression visitLiteralExpression(PostgreSQLParser.LiteralExpressionContext ctx) {
<span class="fc" id="L218">        return (Expression) visit(ctx.literal());</span>
    }
    
    @Override
    public LiteralExpression visitStringLiteral(PostgreSQLParser.StringLiteralContext ctx) {
<span class="fc" id="L223">        String text = ctx.STRING().getText();</span>
        // Remove quotes
<span class="fc" id="L225">        String value = text.substring(1, text.length() - 1);</span>
<span class="fc" id="L226">        return new LiteralExpression(value, LiteralExpression.LiteralType.STRING);</span>
    }
    
    @Override
    public LiteralExpression visitIntegerLiteral(PostgreSQLParser.IntegerLiteralContext ctx) {
<span class="fc" id="L231">        Long value = Long.parseLong(ctx.INTEGER_LITERAL().getText());</span>
<span class="fc" id="L232">        return new LiteralExpression(value, LiteralExpression.LiteralType.INTEGER);</span>
    }
    
    @Override
    public LiteralExpression visitDecimalLiteral(PostgreSQLParser.DecimalLiteralContext ctx) {
<span class="fc" id="L237">        String decimalText = ctx.DECIMAL_LITERAL().getText();</span>
<span class="fc" id="L238">        BigDecimal value = new BigDecimal(decimalText);</span>
<span class="fc" id="L239">        return new LiteralExpression(value, LiteralExpression.LiteralType.DECIMAL);</span>
    }
    
    @Override
    public LiteralExpression visitBooleanLiteral(PostgreSQLParser.BooleanLiteralContext ctx) {
<span class="fc bfc" id="L244" title="All 2 branches covered.">        Boolean value = ctx.TRUE() != null;</span>
<span class="fc" id="L245">        return new LiteralExpression(value, LiteralExpression.LiteralType.BOOLEAN);</span>
    }
    
    @Override
    public LiteralExpression visitNullLiteral(PostgreSQLParser.NullLiteralContext ctx) {
<span class="nc" id="L250">        return new LiteralExpression(null, LiteralExpression.LiteralType.NULL);</span>
    }
    
    @Override
    public Expression visitColumnReferenceExpression(PostgreSQLParser.ColumnReferenceExpressionContext ctx) {
<span class="fc" id="L255">        return (Expression) visit(ctx.columnReference());</span>
    }
    
    @Override
    public ColumnReference visitColumnReference(PostgreSQLParser.ColumnReferenceContext ctx) {
<span class="fc bfc" id="L260" title="All 2 branches covered.">        if (ctx.tableName() != null) {</span>
<span class="fc" id="L261">            String tableName = ctx.tableName().getText();</span>
<span class="fc" id="L262">            String columnName = ctx.columnName().getText();</span>
<span class="fc" id="L263">            return new ColumnReference(tableName, columnName);</span>
        } else {
<span class="fc" id="L265">            String columnName = ctx.columnName().getText();</span>
<span class="fc" id="L266">            return new ColumnReference(columnName);</span>
        }
    }
    
    @Override
    public Expression visitBinaryExpression(PostgreSQLParser.BinaryExpressionContext ctx) {
<span class="fc" id="L272">        Expression left = (Expression) visit(ctx.expression(0));</span>
<span class="fc" id="L273">        Expression right = (Expression) visit(ctx.expression(1));</span>
<span class="fc" id="L274">        BinaryExpression.Operator operator = getBinaryOperator(ctx.binaryOperator());</span>
<span class="fc" id="L275">        return new BinaryExpression(left, operator, right);</span>
    }
    
    @Override
    public Expression visitFunctionCallExpression(PostgreSQLParser.FunctionCallExpressionContext ctx) {
<span class="fc" id="L280">        return (Expression) visit(ctx.functionCall());</span>
    }
    
    @Override
    public FunctionCall visitGenRandomUuidFunction(PostgreSQLParser.GenRandomUuidFunctionContext ctx) {
<span class="fc" id="L285">        return new FunctionCall(&quot;gen_random_uuid&quot;, List.of());</span>
    }
    
    @Override
    public FunctionCall visitUuidGenerateV1Function(PostgreSQLParser.UuidGenerateV1FunctionContext ctx) {
<span class="nc" id="L290">        return new FunctionCall(&quot;uuid_generate_v1&quot;, List.of());</span>
    }
    
    @Override
    public FunctionCall visitUuidGenerateV4Function(PostgreSQLParser.UuidGenerateV4FunctionContext ctx) {
<span class="nc" id="L295">        return new FunctionCall(&quot;uuid_generate_v4&quot;, List.of());</span>
    }
    
    @Override
    public FunctionCall visitGenericFunction(PostgreSQLParser.GenericFunctionContext ctx) {
<span class="nc" id="L300">        String functionName = ctx.identifier().getText();</span>
<span class="nc" id="L301">        List&lt;Expression&gt; arguments = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">        if (ctx.expressionList() != null) {</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">            for (PostgreSQLParser.ExpressionContext exprCtx : ctx.expressionList().expression()) {</span>
<span class="nc" id="L304">                arguments.add((Expression) visit(exprCtx));</span>
<span class="nc" id="L305">            }</span>
        }
<span class="nc" id="L307">        return new FunctionCall(functionName, arguments);</span>
    }
    
    @Override
    public SubqueryExpression visitSubqueryExpression(PostgreSQLParser.SubqueryExpressionContext ctx) {
<span class="fc" id="L312">        SelectStatement selectStatement = (SelectStatement) visit(ctx.selectStatement());</span>
<span class="fc" id="L313">        return new SubqueryExpression(selectStatement);</span>
    }
    
    @Override
    public ExistsExpression visitExistsExpression(PostgreSQLParser.ExistsExpressionContext ctx) {
<span class="fc" id="L318">        SelectStatement subquery = (SelectStatement) visit(ctx.selectStatement());</span>
<span class="fc" id="L319">        return new ExistsExpression(subquery);</span>
    }
    
    @Override
    public InSubqueryExpression visitInSubqueryExpression(PostgreSQLParser.InSubqueryExpressionContext ctx) {
<span class="fc" id="L324">        Expression expression = (Expression) visit(ctx.expression());</span>
<span class="fc" id="L325">        SelectStatement subquery = (SelectStatement) visit(ctx.selectStatement());</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">        boolean negated = ctx.NOT() != null;</span>
<span class="fc" id="L327">        return new InSubqueryExpression(expression, subquery, negated);</span>
    }
    
    @Override
    public AggregateFunction visitCountFunction(PostgreSQLParser.CountFunctionContext ctx) {
<span class="fc bfc" id="L332" title="All 2 branches covered.">        if (ctx.MULTIPLY() != null) {</span>
            // COUNT(*)
<span class="fc" id="L334">            return new AggregateFunction(AggregateFunction.AggregateType.COUNT, null);</span>
        } else {
            // COUNT(expression)
<span class="fc" id="L337">            Expression expr = (Expression) visit(ctx.expression());</span>
<span class="fc" id="L338">            return new AggregateFunction(AggregateFunction.AggregateType.COUNT, expr);</span>
        }
    }
    
    @Override
    public AggregateFunction visitSumFunction(PostgreSQLParser.SumFunctionContext ctx) {
<span class="fc" id="L344">        Expression expr = (Expression) visit(ctx.expression());</span>
<span class="fc" id="L345">        return new AggregateFunction(AggregateFunction.AggregateType.SUM, expr);</span>
    }
    
    @Override
    public AggregateFunction visitAvgFunction(PostgreSQLParser.AvgFunctionContext ctx) {
<span class="fc" id="L350">        Expression expr = (Expression) visit(ctx.expression());</span>
<span class="fc" id="L351">        return new AggregateFunction(AggregateFunction.AggregateType.AVG, expr);</span>
    }
    
    @Override
    public AggregateFunction visitMinFunction(PostgreSQLParser.MinFunctionContext ctx) {
<span class="fc" id="L356">        Expression expr = (Expression) visit(ctx.expression());</span>
<span class="fc" id="L357">        return new AggregateFunction(AggregateFunction.AggregateType.MIN, expr);</span>
    }
    
    @Override
    public AggregateFunction visitMaxFunction(PostgreSQLParser.MaxFunctionContext ctx) {
<span class="fc" id="L362">        Expression expr = (Expression) visit(ctx.expression());</span>
<span class="fc" id="L363">        return new AggregateFunction(AggregateFunction.AggregateType.MAX, expr);</span>
    }
    
    @Override
    public AggregateFunction visitCountDistinctFunction(PostgreSQLParser.CountDistinctFunctionContext ctx) {
<span class="nc" id="L368">        Expression expr = (Expression) visit(ctx.expression());</span>
<span class="nc" id="L369">        return new AggregateFunction(AggregateFunction.AggregateType.COUNT_DISTINCT, expr);</span>
    }
    
    // INSERT statement
    @Override
    public InsertStatement visitInsertStatement(PostgreSQLParser.InsertStatementContext ctx) {
<span class="fc" id="L375">        String tableName = ctx.tableName().getText();</span>
        
<span class="fc" id="L377">        Optional&lt;List&lt;String&gt;&gt; columns = Optional.empty();</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">        if (ctx.columnList() != null) {</span>
<span class="fc" id="L379">            List&lt;String&gt; columnNames = ctx.columnList().columnName().stream()</span>
<span class="fc" id="L380">                .map(c -&gt; c.getText())</span>
<span class="fc" id="L381">                .collect(Collectors.toList());</span>
<span class="fc" id="L382">            columns = Optional.of(columnNames);</span>
        }
        
<span class="fc" id="L385">        List&lt;List&lt;Expression&gt;&gt; valuesList = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">        for (PostgreSQLParser.ValuesClauseContext valuesCtx : ctx.valuesClause()) {</span>
<span class="fc" id="L387">            List&lt;Expression&gt; values = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">            for (PostgreSQLParser.ExpressionContext exprCtx : valuesCtx.expression()) {</span>
<span class="fc" id="L389">                values.add((Expression) visit(exprCtx));</span>
<span class="fc" id="L390">            }</span>
<span class="fc" id="L391">            valuesList.add(values);</span>
<span class="fc" id="L392">        }</span>
        
<span class="fc" id="L394">        return new InsertStatement(tableName, columns, valuesList);</span>
    }
    
    // UPDATE statement
    @Override
    public UpdateStatement visitUpdateStatement(PostgreSQLParser.UpdateStatementContext ctx) {
<span class="fc" id="L400">        String tableName = ctx.tableName().getText();</span>
        
<span class="fc" id="L402">        List&lt;UpdateStatement.UpdateItem&gt; updateItems = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">        for (PostgreSQLParser.UpdateItemContext updateCtx : ctx.updateItem()) {</span>
<span class="fc" id="L404">            String columnName = updateCtx.columnName().getText();</span>
<span class="fc" id="L405">            Expression value = (Expression) visit(updateCtx.expression());</span>
<span class="fc" id="L406">            updateItems.add(new UpdateStatement.UpdateItem(columnName, value));</span>
<span class="fc" id="L407">        }</span>
        
<span class="pc bpc" id="L409" title="1 of 2 branches missed.">        Optional&lt;WhereClause&gt; whereClause = ctx.whereClause() != null ? </span>
<span class="pc" id="L410">            Optional.of((WhereClause) visit(ctx.whereClause())) : Optional.empty();</span>
        
<span class="fc" id="L412">        return new UpdateStatement(tableName, updateItems, whereClause);</span>
    }
    
    // DELETE statement
    @Override
    public DeleteStatement visitDeleteStatement(PostgreSQLParser.DeleteStatementContext ctx) {
<span class="fc" id="L418">        String tableName = ctx.tableName().getText();</span>
        
<span class="pc bpc" id="L420" title="1 of 2 branches missed.">        Optional&lt;WhereClause&gt; whereClause = ctx.whereClause() != null ? </span>
<span class="pc" id="L421">            Optional.of((WhereClause) visit(ctx.whereClause())) : Optional.empty();</span>
        
<span class="fc" id="L423">        return new DeleteStatement(tableName, whereClause);</span>
    }
    
    // CREATE TABLE statement
    @Override
    public CreateTableStatement visitCreateTableStatement(PostgreSQLParser.CreateTableStatementContext ctx) {
<span class="fc" id="L429">        String tableName = ctx.tableName().getText();</span>
        
<span class="fc" id="L431">        List&lt;ColumnDefinition&gt; columnDefinitions = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">        for (PostgreSQLParser.ColumnDefinitionContext colCtx : ctx.columnDefinition()) {</span>
<span class="fc" id="L433">            String columnName = colCtx.columnName().getText();</span>
<span class="fc" id="L434">            DataTypeNode dataType = (DataTypeNode) visit(colCtx.dataType());</span>
            
<span class="fc" id="L436">            List&lt;ColumnDefinition.Constraint&gt; constraints = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L437" title="1 of 2 branches missed.">            if (colCtx.columnConstraint() != null) {</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">                for (PostgreSQLParser.ColumnConstraintContext constraintCtx : colCtx.columnConstraint()) {</span>
<span class="pc bpc" id="L439" title="1 of 4 branches missed.">                    if (constraintCtx.NOT() != null &amp;&amp; constraintCtx.NULL() != null) {</span>
<span class="fc" id="L440">                        constraints.add(ColumnDefinition.Constraint.NOT_NULL);</span>
<span class="pc bpc" id="L441" title="1 of 4 branches missed.">                    } else if (constraintCtx.PRIMARY() != null &amp;&amp; constraintCtx.KEY() != null) {</span>
<span class="fc" id="L442">                        constraints.add(ColumnDefinition.Constraint.PRIMARY_KEY);</span>
<span class="pc bpc" id="L443" title="1 of 2 branches missed.">                    } else if (constraintCtx.UNIQUE() != null) {</span>
<span class="fc" id="L444">                        constraints.add(ColumnDefinition.Constraint.UNIQUE);</span>
                    }
<span class="fc" id="L446">                }</span>
            }
            
<span class="fc" id="L449">            columnDefinitions.add(new ColumnDefinition(columnName, dataType, constraints));</span>
<span class="fc" id="L450">        }</span>
        
<span class="fc" id="L452">        return new CreateTableStatement(tableName, columnDefinitions);</span>
    }
    
    // DROP TABLE statement
    @Override
    public DropTableStatement visitDropTableStatement(PostgreSQLParser.DropTableStatementContext ctx) {
<span class="nc" id="L458">        String tableName = ctx.tableName().getText();</span>
<span class="nc" id="L459">        return new DropTableStatement(tableName);</span>
    }
    
    // Data type visitors
    @Override
    public DataTypeNode visitIntegerType(PostgreSQLParser.IntegerTypeContext ctx) {
<span class="fc" id="L465">        return new DataTypeNode(DataType.INTEGER);</span>
    }
    
    @Override
    public DataTypeNode visitBigintType(PostgreSQLParser.BigintTypeContext ctx) {
<span class="nc" id="L470">        return new DataTypeNode(DataType.BIGINT);</span>
    }
    
    @Override
    public DataTypeNode visitSmallintType(PostgreSQLParser.SmallintTypeContext ctx) {
<span class="nc" id="L475">        return new DataTypeNode(DataType.SMALLINT);</span>
    }
    
    @Override
    public DataTypeNode visitVarcharType(PostgreSQLParser.VarcharTypeContext ctx) {
<span class="fc" id="L480">        return new DataTypeNode(DataType.VARCHAR);</span>
    }
    
    @Override
    public DataTypeNode visitTextType(PostgreSQLParser.TextTypeContext ctx) {
<span class="fc" id="L485">        return new DataTypeNode(DataType.TEXT);</span>
    }
    
    @Override
    public DataTypeNode visitCharType(PostgreSQLParser.CharTypeContext ctx) {
<span class="nc" id="L490">        return new DataTypeNode(DataType.CHAR);</span>
    }
    
    @Override
    public DataTypeNode visitBooleanType(PostgreSQLParser.BooleanTypeContext ctx) {
<span class="fc" id="L495">        return new DataTypeNode(DataType.BOOLEAN);</span>
    }
    
    @Override
    public DataTypeNode visitUuidType(PostgreSQLParser.UuidTypeContext ctx) {
<span class="fc" id="L500">        return new DataTypeNode(DataType.UUID);</span>
    }
    
    @Override
    public DataTypeNode visitJsonbType(PostgreSQLParser.JsonbTypeContext ctx) {
<span class="nc" id="L505">        return new DataTypeNode(DataType.JSONB);</span>
    }
    
    @Override
    public DataTypeNode visitRealType(PostgreSQLParser.RealTypeContext ctx) {
<span class="nc" id="L510">        return new DataTypeNode(DataType.REAL);</span>
    }
    
    @Override
    public DataTypeNode visitDoublePrecisionType(PostgreSQLParser.DoublePrecisionTypeContext ctx) {
<span class="nc" id="L515">        return new DataTypeNode(DataType.DOUBLE_PRECISION);</span>
    }
    
    @Override
    public DataTypeNode visitDecimalType(PostgreSQLParser.DecimalTypeContext ctx) {
<span class="fc" id="L520">        return new DataTypeNode(DataType.DECIMAL);</span>
    }
    
    @Override
    public DataTypeNode visitNumericType(PostgreSQLParser.NumericTypeContext ctx) {
<span class="nc" id="L525">        return new DataTypeNode(DataType.DECIMAL);</span>
    }
    
    @Override
    public DataTypeNode visitDateType(PostgreSQLParser.DateTypeContext ctx) {
<span class="nc" id="L530">        return new DataTypeNode(DataType.DATE);</span>
    }
    
    @Override
    public DataTypeNode visitTimeType(PostgreSQLParser.TimeTypeContext ctx) {
<span class="nc" id="L535">        return new DataTypeNode(DataType.TIME);</span>
    }
    
    @Override
    public DataTypeNode visitTimestampType(PostgreSQLParser.TimestampTypeContext ctx) {
<span class="nc" id="L540">        return new DataTypeNode(DataType.TIMESTAMP);</span>
    }
    
    @Override
    public DataTypeNode visitTimestamptzType(PostgreSQLParser.TimestamptzTypeContext ctx) {
<span class="nc" id="L545">        return new DataTypeNode(DataType.TIMESTAMPTZ);</span>
    }
    
    @Override
    public DataTypeNode visitByteaType(PostgreSQLParser.ByteaTypeContext ctx) {
<span class="nc" id="L550">        return new DataTypeNode(DataType.BYTEA);</span>
    }
    
    /**
     * Convert ANTLR4 binary operator context to our BinaryExpression.Operator enum.
     */
    private BinaryExpression.Operator getBinaryOperator(PostgreSQLParser.BinaryOperatorContext ctx) {
<span class="fc bfc" id="L557" title="All 2 branches covered.">        if (ctx.EQ() != null) return BinaryExpression.Operator.EQUALS;</span>
<span class="pc bpc" id="L558" title="1 of 2 branches missed.">        if (ctx.NE() != null) return BinaryExpression.Operator.NOT_EQUALS;</span>
<span class="pc bpc" id="L559" title="1 of 2 branches missed.">        if (ctx.LT() != null) return BinaryExpression.Operator.LESS_THAN;</span>
<span class="pc bpc" id="L560" title="1 of 2 branches missed.">        if (ctx.LE() != null) return BinaryExpression.Operator.LESS_THAN_EQUALS;</span>
<span class="fc bfc" id="L561" title="All 2 branches covered.">        if (ctx.GT() != null) return BinaryExpression.Operator.GREATER_THAN;</span>
<span class="pc bpc" id="L562" title="1 of 2 branches missed.">        if (ctx.GE() != null) return BinaryExpression.Operator.GREATER_THAN_EQUALS;</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">        if (ctx.PLUS() != null) return BinaryExpression.Operator.ADD;</span>
<span class="fc bfc" id="L564" title="All 2 branches covered.">        if (ctx.MINUS() != null) return BinaryExpression.Operator.SUBTRACT;</span>
<span class="pc bpc" id="L565" title="1 of 2 branches missed.">        if (ctx.MULTIPLY() != null) return BinaryExpression.Operator.MULTIPLY;</span>
<span class="pc bpc" id="L566" title="1 of 2 branches missed.">        if (ctx.DIVIDE() != null) return BinaryExpression.Operator.DIVIDE;</span>
<span class="pc bpc" id="L567" title="1 of 2 branches missed.">        if (ctx.MODULO() != null) return BinaryExpression.Operator.MODULO;</span>
<span class="pc bpc" id="L568" title="1 of 2 branches missed.">        if (ctx.POWER() != null) return BinaryExpression.Operator.POWER;</span>
<span class="pc bpc" id="L569" title="1 of 2 branches missed.">        if (ctx.AND() != null) return BinaryExpression.Operator.AND;</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">        if (ctx.OR() != null) return BinaryExpression.Operator.OR;</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">        if (ctx.CONCAT() != null) return BinaryExpression.Operator.CONCAT;</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">        if (ctx.JSONB_CONTAINS() != null) return BinaryExpression.Operator.JSONB_CONTAINS;</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">        if (ctx.JSONB_CONTAINED() != null) return BinaryExpression.Operator.JSONB_CONTAINED;</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">        if (ctx.JSONB_EXISTS() != null) return BinaryExpression.Operator.JSONB_EXISTS;</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">        if (ctx.JSONB_EXTRACT() != null) return BinaryExpression.Operator.JSONB_EXTRACT;</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">        if (ctx.JSONB_EXTRACT_TEXT() != null) return BinaryExpression.Operator.JSONB_EXTRACT_TEXT;</span>
<span class="nc bnc" id="L577" title="All 2 branches missed.">        if (ctx.JSONB_PATH_EXTRACT() != null) return BinaryExpression.Operator.JSONB_PATH_EXTRACT;</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">        if (ctx.JSONB_PATH_EXTRACT_TEXT() != null) return BinaryExpression.Operator.JSONB_PATH_EXTRACT_TEXT;</span>
        
<span class="nc" id="L580">        throw new IllegalArgumentException(&quot;Unknown binary operator: &quot; + ctx.getText());</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>