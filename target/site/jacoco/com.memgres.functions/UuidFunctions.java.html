<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UuidFunctions.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">MemGres Core</a> &gt; <a href="index.source.html" class="el_package">com.memgres.functions</a> &gt; <span class="el_source">UuidFunctions.java</span></div><h1>UuidFunctions.java</h1><pre class="source lang-java linenums">package com.memgres.functions;

import java.net.NetworkInterface;
import java.security.SecureRandom;
import java.time.Instant;
import java.util.Enumeration;
import java.util.UUID;

/**
 * PostgreSQL-compatible UUID generation functions for MemGres.
 * Provides gen_random_uuid(), uuid_generate_v1(), and uuid_generate_v4() functions.
 */
<span class="nc" id="L13">public class UuidFunctions {</span>
    
<span class="fc" id="L15">    private static final SecureRandom SECURE_RANDOM = new SecureRandom();</span>
<span class="fc" id="L16">    private static volatile long clockSequence = -1;</span>
<span class="fc" id="L17">    private static volatile byte[] nodeId = null;</span>
    
    // Initialize node ID and clock sequence for UUID v1 generation
    static {
<span class="fc" id="L21">        initializeNodeIdAndClock();</span>
<span class="fc" id="L22">    }</span>
    
    /**
     * Generate a random UUID (equivalent to PostgreSQL's gen_random_uuid()).
     * Uses cryptographically secure random number generation.
     * 
     * @return a new random UUID
     */
    public static UUID genRandomUuid() {
<span class="fc" id="L31">        byte[] randomBytes = new byte[16];</span>
<span class="fc" id="L32">        SECURE_RANDOM.nextBytes(randomBytes);</span>
        
        // Set version (4) and variant bits according to RFC 4122
<span class="fc" id="L35">        randomBytes[6] = (byte) ((randomBytes[6] &amp; 0x0f) | 0x40); // Version 4</span>
<span class="fc" id="L36">        randomBytes[8] = (byte) ((randomBytes[8] &amp; 0x3f) | 0x80); // Variant 10</span>
        
<span class="fc" id="L38">        long mostSigBits = 0;</span>
<span class="fc" id="L39">        long leastSigBits = 0;</span>
        
<span class="fc bfc" id="L41" title="All 2 branches covered.">        for (int i = 0; i &lt; 8; i++) {</span>
<span class="fc" id="L42">            mostSigBits = (mostSigBits &lt;&lt; 8) | (randomBytes[i] &amp; 0xff);</span>
        }
        
<span class="fc bfc" id="L45" title="All 2 branches covered.">        for (int i = 8; i &lt; 16; i++) {</span>
<span class="fc" id="L46">            leastSigBits = (leastSigBits &lt;&lt; 8) | (randomBytes[i] &amp; 0xff);</span>
        }
        
<span class="fc" id="L49">        return new UUID(mostSigBits, leastSigBits);</span>
    }
    
    /**
     * Generate a UUID version 1 (time-based) with MAC address and timestamp.
     * Compatible with PostgreSQL's uuid_generate_v1().
     * 
     * @return a new time-based UUID
     */
    public static synchronized UUID uuidGenerateV1() {
        // Get current timestamp in 100-nanosecond intervals since UUID epoch (Oct 15, 1582)
<span class="fc" id="L60">        long currentTimeNanos = System.nanoTime();</span>
<span class="fc" id="L61">        long currentTimeMillis = System.currentTimeMillis();</span>
<span class="fc" id="L62">        long uuidTime = (currentTimeMillis + 12219292800000L) * 10000L; // Convert to UUID time</span>
        
        // Add nanosecond precision to ensure uniqueness
<span class="fc" id="L65">        uuidTime += (currentTimeNanos % 10000L);</span>
        
        // Time low (32 bits)
<span class="fc" id="L68">        long timeLow = uuidTime &amp; 0xFFFFFFFFL;</span>
        
        // Time mid (16 bits) 
<span class="fc" id="L71">        long timeMid = (uuidTime &gt;&gt; 32) &amp; 0xFFFFL;</span>
        
        // Time high and version (16 bits)
<span class="fc" id="L74">        long timeHiAndVersion = ((uuidTime &gt;&gt; 48) &amp; 0x0FFFL) | 0x1000L; // Version 1</span>
        
        // Generate unique clock sequence for each call to ensure uniqueness
<span class="fc" id="L77">        long uniqueClockSeq = (getClockSequence() + currentTimeNanos) &amp; 0x3FFFL;</span>
<span class="fc" id="L78">        long clockSeqAndNode = (uniqueClockSeq | 0x8000L); // Variant 10</span>
<span class="fc" id="L79">        clockSeqAndNode = (clockSeqAndNode &lt;&lt; 48) | (getNodeId() &amp; 0xFFFFFFFFFFFFL);</span>
        
<span class="fc" id="L81">        long mostSigBits = (timeLow &lt;&lt; 32) | (timeMid &lt;&lt; 16) | timeHiAndVersion;</span>
        
<span class="fc" id="L83">        return new UUID(mostSigBits, clockSeqAndNode);</span>
    }
    
    /**
     * Generate a UUID version 4 (random).
     * Compatible with PostgreSQL's uuid_generate_v4().
     * 
     * @return a new random UUID
     */
    public static UUID uuidGenerateV4() {
<span class="fc" id="L93">        return UUID.randomUUID();</span>
    }
    
    /**
     * Initialize node ID and clock sequence for UUID v1 generation.
     */
    private static void initializeNodeIdAndClock() {
        try {
            // Try to get MAC address from network interface
<span class="fc" id="L102">            byte[] macAddress = getMacAddress();</span>
<span class="pc bpc" id="L103" title="2 of 4 branches missed.">            if (macAddress != null &amp;&amp; macAddress.length &gt;= 6) {</span>
<span class="fc" id="L104">                nodeId = new byte[6];</span>
<span class="fc" id="L105">                System.arraycopy(macAddress, 0, nodeId, 0, 6);</span>
            } else {
                // Fallback to random node ID with multicast bit set
<span class="nc" id="L108">                nodeId = new byte[6];</span>
<span class="nc" id="L109">                SECURE_RANDOM.nextBytes(nodeId);</span>
<span class="nc" id="L110">                nodeId[0] |= 0x01; // Set multicast bit to indicate random node ID</span>
            }
            
            // Initialize clock sequence with random value
<span class="fc" id="L114">            clockSequence = SECURE_RANDOM.nextInt(16384); // 14-bit value</span>
            
<span class="nc" id="L116">        } catch (Exception e) {</span>
            // Fallback to random values
<span class="nc" id="L118">            nodeId = new byte[6];</span>
<span class="nc" id="L119">            SECURE_RANDOM.nextBytes(nodeId);</span>
<span class="nc" id="L120">            nodeId[0] |= 0x01; // Set multicast bit</span>
<span class="nc" id="L121">            clockSequence = SECURE_RANDOM.nextInt(16384);</span>
<span class="fc" id="L122">        }</span>
<span class="fc" id="L123">    }</span>
    
    /**
     * Get MAC address from available network interfaces.
     */
    private static byte[] getMacAddress() {
        try {
<span class="fc" id="L130">            Enumeration&lt;NetworkInterface&gt; networkInterfaces = NetworkInterface.getNetworkInterfaces();</span>
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">            while (networkInterfaces.hasMoreElements()) {</span>
<span class="fc" id="L132">                NetworkInterface networkInterface = networkInterfaces.nextElement();</span>
<span class="fc" id="L133">                byte[] macAddress = networkInterface.getHardwareAddress();</span>
                
<span class="pc bpc" id="L135" title="2 of 6 branches missed.">                if (macAddress != null &amp;&amp; macAddress.length == 6 &amp;&amp; !isLocalAddress(macAddress)) {</span>
<span class="fc" id="L136">                    return macAddress;</span>
                }
<span class="fc" id="L138">            }</span>
<span class="nc" id="L139">        } catch (Exception e) {</span>
            // Ignore and return null to use random node ID
<span class="nc" id="L141">        }</span>
<span class="nc" id="L142">        return null;</span>
    }
    
    /**
     * Check if MAC address is a local/virtual address.
     */
    private static boolean isLocalAddress(byte[] macAddress) {
        // Check for common local/virtual MAC address patterns
<span class="pc bpc" id="L150" title="5 of 6 branches missed.">        return macAddress[0] == 0x00 &amp;&amp; macAddress[1] == 0x00 &amp;&amp; macAddress[2] == 0x00;</span>
    }
    
    /**
     * Get the clock sequence for UUID generation.
     */
    private static long getClockSequence() {
<span class="fc" id="L157">        return clockSequence;</span>
    }
    
    /**
     * Get the node ID as a long value.
     */
    private static long getNodeId() {
<span class="fc" id="L164">        long result = 0;</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">        for (int i = 0; i &lt; 6; i++) {</span>
<span class="fc" id="L166">            result = (result &lt;&lt; 8) | (nodeId[i] &amp; 0xFF);</span>
        }
<span class="fc" id="L168">        return result;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>