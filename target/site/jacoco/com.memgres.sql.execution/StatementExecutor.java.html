<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StatementExecutor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">MemGres Core</a> &gt; <a href="index.source.html" class="el_package">com.memgres.sql.execution</a> &gt; <span class="el_source">StatementExecutor.java</span></div><h1>StatementExecutor.java</h1><pre class="source lang-java linenums">package com.memgres.sql.execution;

import com.memgres.core.MemGresEngine;
import com.memgres.functions.UuidFunctions;
import com.memgres.sql.ast.AstVisitor;
import com.memgres.sql.ast.expression.*;
import com.memgres.sql.ast.statement.*;
import com.memgres.storage.Table;
import com.memgres.types.Column;
import com.memgres.types.DataType;
import com.memgres.types.Row;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Executes SQL statement AST nodes against the MemGres storage layer.
 */
public class StatementExecutor implements AstVisitor&lt;SqlExecutionResult, ExecutionContext&gt; {
<span class="fc" id="L22">    private static final Logger logger = LoggerFactory.getLogger(StatementExecutor.class);</span>
    
    private final MemGresEngine engine;
    private final ExpressionEvaluator expressionEvaluator;
    
<span class="fc" id="L27">    public StatementExecutor(MemGresEngine engine) {</span>
<span class="fc" id="L28">        this.engine = engine;</span>
<span class="fc" id="L29">        this.expressionEvaluator = new ExpressionEvaluator(engine);</span>
<span class="fc" id="L30">    }</span>
    
    /**
     * Execute a statement and return the result.
     */
    public SqlExecutionResult execute(Statement statement) throws SqlExecutionException {
        try {
<span class="fc" id="L37">            ExecutionContext context = new ExecutionContext();</span>
<span class="fc" id="L38">            return statement.accept(this, context);</span>
<span class="fc" id="L39">        } catch (Exception e) {</span>
<span class="pc bpc" id="L40" title="1 of 2 branches missed.">            if (e instanceof SqlExecutionException) {</span>
<span class="fc" id="L41">                throw (SqlExecutionException) e;</span>
            }
<span class="nc" id="L43">            throw new SqlExecutionException(&quot;Failed to execute statement&quot;, e);</span>
        }
    }
    
    /**
     * Execute a statement with a provided execution context (for correlated subqueries).
     */
    public SqlExecutionResult execute(Statement statement, ExecutionContext context) throws SqlExecutionException {
        try {
<span class="fc" id="L52">            return statement.accept(this, context);</span>
<span class="nc" id="L53">        } catch (Exception e) {</span>
<span class="nc bnc" id="L54" title="All 2 branches missed.">            if (e instanceof SqlExecutionException) {</span>
<span class="nc" id="L55">                throw (SqlExecutionException) e;</span>
            }
<span class="nc" id="L57">            throw new SqlExecutionException(&quot;Failed to execute statement&quot;, e);</span>
        }
    }
    
    @Override
    public SqlExecutionResult visitSelectStatement(SelectStatement node, ExecutionContext context) throws SqlExecutionException {
        try {
            // Process FROM clause and execute joins (or create empty row for subqueries without FROM)
            JoinResult joinResult;
<span class="fc bfc" id="L66" title="All 2 branches covered.">            if (node.getFromClause().isPresent()) {</span>
<span class="fc" id="L67">                FromClause fromClause = node.getFromClause().get();</span>
<span class="fc" id="L68">                joinResult = executeFromClause(fromClause, context);</span>
<span class="fc" id="L69">            } else {</span>
                // No FROM clause - create a single empty row for expression evaluation
<span class="fc" id="L71">                joinResult = new JoinResult(List.of(), List.of(new Row(0L, new Object[0])));</span>
            }
            
<span class="fc" id="L74">            List&lt;Row&gt; filteredRows = joinResult.rows;</span>
            
            // Apply WHERE clause if present
<span class="fc bfc" id="L77" title="All 2 branches covered.">            if (node.getWhereClause().isPresent()) {</span>
<span class="fc" id="L78">                WhereClause whereClause = node.getWhereClause().get();</span>
<span class="fc" id="L79">                filteredRows = new ArrayList&lt;&gt;();</span>
                
<span class="fc bfc" id="L81" title="All 2 branches covered.">                for (Row row : joinResult.rows) {</span>
<span class="fc" id="L82">                    context.setCurrentRow(row);</span>
<span class="fc" id="L83">                    context.setJoinedColumns(joinResult.columns);</span>
                    
<span class="fc" id="L85">                    Object result = expressionEvaluator.evaluate(whereClause.getCondition(), context);</span>
                    
<span class="fc bfc" id="L87" title="All 2 branches covered.">                    if (Boolean.TRUE.equals(result)) {</span>
<span class="fc" id="L88">                        filteredRows.add(row);</span>
                    }
<span class="fc" id="L90">                }</span>
            }
            
            
            // Handle GROUP BY and aggregation
<span class="fc" id="L95">            List&lt;Row&gt; groupedRows = filteredRows;</span>
<span class="fc" id="L96">            List&lt;Column&gt; groupedColumns = joinResult.columns;</span>
            
<span class="fc bfc" id="L98" title="All 4 branches covered.">            if (node.getGroupByClause().isPresent() || hasAggregateFunction(node.getSelectItems())) {</span>
<span class="fc" id="L99">                AggregationResult aggregationResult = performAggregation(node, filteredRows, joinResult.columns, context);</span>
<span class="fc" id="L100">                groupedRows = aggregationResult.rows;</span>
<span class="fc" id="L101">                groupedColumns = aggregationResult.columns;</span>
            }
            
            // Apply HAVING clause if present
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">            if (node.getHavingClause().isPresent()) {</span>
<span class="nc" id="L106">                HavingClause havingClause = node.getHavingClause().get();</span>
<span class="nc" id="L107">                List&lt;Row&gt; havingFilteredRows = new ArrayList&lt;&gt;();</span>
                
<span class="nc bnc" id="L109" title="All 2 branches missed.">                for (Row row : groupedRows) {</span>
<span class="nc" id="L110">                    context.setCurrentRow(row);</span>
<span class="nc" id="L111">                    context.setJoinedColumns(groupedColumns);</span>
                    
<span class="nc" id="L113">                    Object result = expressionEvaluator.evaluate(havingClause.getCondition(), context);</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">                    if (Boolean.TRUE.equals(result)) {</span>
<span class="nc" id="L115">                        havingFilteredRows.add(row);</span>
                    }
<span class="nc" id="L117">                }</span>
<span class="nc" id="L118">                groupedRows = havingFilteredRows;</span>
            }
            
            // Apply ORDER BY if present (on grouped results)
<span class="fc bfc" id="L122" title="All 2 branches covered.">            if (node.getOrderByClause().isPresent()) {</span>
<span class="fc" id="L123">                OrderByClause orderBy = node.getOrderByClause().get();</span>
<span class="fc" id="L124">                groupedRows = applyOrderBy(groupedRows, orderBy, context, groupedColumns);</span>
            }
            
            // Apply LIMIT if present
<span class="fc bfc" id="L128" title="All 2 branches covered.">            if (node.getLimitClause().isPresent()) {</span>
<span class="fc" id="L129">                LimitClause limitClause = node.getLimitClause().get();</span>
<span class="fc" id="L130">                int limit = evaluateIntExpression(limitClause.getLimit(), context);</span>
<span class="fc" id="L131">                int offset = 0;</span>
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">                if (limitClause.getOffset().isPresent()) {</span>
<span class="nc" id="L133">                    offset = evaluateIntExpression(limitClause.getOffset().get(), context);</span>
                }
                
<span class="fc" id="L136">                int fromIndex = Math.min(offset, groupedRows.size());</span>
<span class="fc" id="L137">                int toIndex = Math.min(fromIndex + limit, groupedRows.size());</span>
<span class="fc" id="L138">                groupedRows = groupedRows.subList(fromIndex, toIndex);</span>
            }
            
            // Project columns based on SELECT list
            List&lt;Column&gt; resultColumns;
            List&lt;Row&gt; resultRows;
            
<span class="fc bfc" id="L145" title="All 4 branches covered.">            if (node.getGroupByClause().isPresent() || hasAggregateFunction(node.getSelectItems())) {</span>
                // Aggregation already handled projection - use results directly
<span class="fc" id="L147">                resultColumns = groupedColumns;</span>
<span class="fc" id="L148">                resultRows = groupedRows;</span>
<span class="fc bfc" id="L149" title="All 4 branches covered.">            } else if (node.getSelectItems().size() == 1 &amp;&amp; node.getSelectItems().get(0).isWildcard()) {</span>
                // SELECT * - return all columns
<span class="fc" id="L151">                resultColumns = groupedColumns;</span>
<span class="fc" id="L152">                resultRows = groupedRows;</span>
            } else {
                // Project specific columns/expressions (non-aggregate case)
<span class="fc" id="L155">                resultColumns = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L156">                resultRows = new ArrayList&lt;&gt;();</span>
                
                // Validate column references in SELECT items
<span class="fc" id="L159">                context.setJoinedColumns(groupedColumns);</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">                for (SelectItem item : node.getSelectItems()) {</span>
<span class="fc" id="L161">                    validateColumnReferences(item.getExpression(), groupedColumns);</span>
<span class="fc" id="L162">                }</span>
                
                // Determine result columns
<span class="fc bfc" id="L165" title="All 2 branches covered.">                for (int i = 0; i &lt; node.getSelectItems().size(); i++) {</span>
<span class="fc" id="L166">                    SelectItem item = node.getSelectItems().get(i);</span>
                    String columnName;
<span class="fc bfc" id="L168" title="All 2 branches covered.">                    if (item.getAlias().isPresent()) {</span>
<span class="fc" id="L169">                        columnName = item.getAlias().get();</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">                    } else if (item.getExpression() instanceof com.memgres.sql.ast.expression.ColumnReference) {</span>
<span class="fc" id="L171">                        com.memgres.sql.ast.expression.ColumnReference colRef = </span>
<span class="fc" id="L172">                            (com.memgres.sql.ast.expression.ColumnReference) item.getExpression();</span>
<span class="fc" id="L173">                        columnName = colRef.getColumnName();</span>
<span class="fc" id="L174">                    } else {</span>
<span class="fc" id="L175">                        columnName = &quot;column&quot; + i;</span>
                    }
<span class="fc" id="L177">                    resultColumns.add(new Column.Builder()</span>
<span class="fc" id="L178">                    .name(columnName)</span>
<span class="fc" id="L179">                    .dataType(DataType.TEXT)</span>
<span class="fc" id="L180">                    .build());</span>
                }
                
                // Project rows
<span class="fc bfc" id="L184" title="All 2 branches covered.">                for (Row row : groupedRows) {</span>
<span class="fc" id="L185">                    context.setCurrentRow(row);</span>
<span class="fc" id="L186">                    context.setJoinedColumns(groupedColumns);</span>
                    
<span class="fc" id="L188">                    Object[] projectedData = new Object[node.getSelectItems().size()];</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">                    for (int i = 0; i &lt; node.getSelectItems().size(); i++) {</span>
<span class="fc" id="L190">                        SelectItem item = node.getSelectItems().get(i);</span>
<span class="fc" id="L191">                        projectedData[i] = expressionEvaluator.evaluate(item.getExpression(), context);</span>
                    }
                    
<span class="fc" id="L194">                    resultRows.add(new Row(row.getId(), projectedData));</span>
<span class="fc" id="L195">                }</span>
            }
            
<span class="fc" id="L198">            logger.debug(&quot;SELECT executed: {} rows returned&quot;, resultRows.size());</span>
<span class="fc" id="L199">            return new SqlExecutionResult(resultColumns, resultRows);</span>
            
<span class="fc" id="L201">        } catch (Exception e) {</span>
<span class="fc" id="L202">            throw new SqlExecutionException(&quot;Failed to execute SELECT statement&quot;, e);</span>
        }
    }
    
    @Override
    public SqlExecutionResult visitInsertStatement(InsertStatement node, ExecutionContext context) throws SqlExecutionException {
        try {
<span class="fc" id="L209">            String tableName = node.getTableName();</span>
<span class="fc" id="L210">            Table table = engine.getTable(&quot;public&quot;, tableName);</span>
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">            if (table == null) {</span>
<span class="nc" id="L212">                throw new SqlExecutionException(&quot;Table not found: &quot; + tableName);</span>
            }
            
<span class="fc" id="L215">            List&lt;Column&gt; tableColumns = table.getColumns();</span>
<span class="fc" id="L216">            int affectedRows = 0;</span>
            
            // Process each set of values
<span class="fc bfc" id="L219" title="All 2 branches covered.">            for (List&lt;Expression&gt; values : node.getValuesList()) {</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">                if (values.size() != tableColumns.size()) {</span>
<span class="fc" id="L221">                    throw new SqlExecutionException(&quot;Column count mismatch: expected &quot; + </span>
<span class="fc" id="L222">                        tableColumns.size() + &quot;, got &quot; + values.size());</span>
                }
                
                // Evaluate values
<span class="fc" id="L226">                Object[] rowData = new Object[values.size()];</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">                for (int i = 0; i &lt; values.size(); i++) {</span>
<span class="fc" id="L228">                    rowData[i] = expressionEvaluator.evaluate(values.get(i), context);</span>
                    
                    // Convert and validate data type
<span class="fc" id="L231">                    Column column = tableColumns.get(i);</span>
<span class="fc" id="L232">                    rowData[i] = column.getDataType().convertValue(rowData[i]);</span>
                    
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">                    if (!column.getDataType().isValidValue(rowData[i])) {</span>
<span class="nc" id="L235">                        throw new SqlExecutionException(&quot;Invalid value for column &quot; + </span>
<span class="nc" id="L236">                            column.getName() + &quot;: &quot; + rowData[i]);</span>
                    }
                }
                
                // Insert row
<span class="fc" id="L241">                table.insertRow(rowData);</span>
<span class="fc" id="L242">                affectedRows++;</span>
<span class="fc" id="L243">            }</span>
            
<span class="fc" id="L245">            logger.debug(&quot;INSERT executed: {} rows inserted into {}&quot;, affectedRows, tableName);</span>
<span class="fc" id="L246">            return new SqlExecutionResult(SqlExecutionResult.ResultType.INSERT, affectedRows);</span>
            
<span class="fc" id="L248">        } catch (Exception e) {</span>
<span class="fc" id="L249">            throw new SqlExecutionException(&quot;Failed to execute INSERT statement&quot;, e);</span>
        }
    }
    
    @Override
    public SqlExecutionResult visitUpdateStatement(UpdateStatement node, ExecutionContext context) throws SqlExecutionException {
        try {
<span class="fc" id="L256">            String tableName = node.getTableName();</span>
<span class="fc" id="L257">            Table table = engine.getTable(&quot;public&quot;, tableName);</span>
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">            if (table == null) {</span>
<span class="nc" id="L259">                throw new SqlExecutionException(&quot;Table not found: &quot; + tableName);</span>
            }
            
            // Get all rows and filter by WHERE clause if present
<span class="fc" id="L263">            List&lt;Row&gt; allRows = table.getAllRows();</span>
<span class="fc" id="L264">            List&lt;Row&gt; rowsToUpdate = allRows;</span>
            
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">            if (node.getWhereClause().isPresent()) {</span>
<span class="fc" id="L267">                WhereClause whereClause = node.getWhereClause().get();</span>
<span class="fc" id="L268">                rowsToUpdate = new ArrayList&lt;&gt;();</span>
                
<span class="fc bfc" id="L270" title="All 2 branches covered.">                for (Row row : allRows) {</span>
<span class="fc" id="L271">                    context.setCurrentRow(row);</span>
<span class="fc" id="L272">                    context.setCurrentTable(table);</span>
                    
<span class="fc" id="L274">                    Object result = expressionEvaluator.evaluate(whereClause.getCondition(), context);</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">                    if (Boolean.TRUE.equals(result)) {</span>
<span class="fc" id="L276">                        rowsToUpdate.add(row);</span>
                    }
<span class="fc" id="L278">                }</span>
            }
            
<span class="fc" id="L281">            int affectedRows = 0;</span>
<span class="fc" id="L282">            List&lt;Column&gt; columns = table.getColumns();</span>
<span class="fc" id="L283">            Map&lt;String, Integer&gt; columnIndexMap = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">            for (int i = 0; i &lt; columns.size(); i++) {</span>
<span class="fc" id="L285">                columnIndexMap.put(columns.get(i).getName().toLowerCase(), i);</span>
            }
            
            // Update each matching row
<span class="fc bfc" id="L289" title="All 2 branches covered.">            for (Row row : rowsToUpdate) {</span>
<span class="fc" id="L290">                context.setCurrentRow(row);</span>
<span class="fc" id="L291">                context.setCurrentTable(table);</span>
                
<span class="fc" id="L293">                Object[] newData = row.getData().clone();</span>
                
                // Apply updates
<span class="fc bfc" id="L296" title="All 2 branches covered.">                for (UpdateStatement.UpdateItem updateItem : node.getUpdateItems()) {</span>
<span class="fc" id="L297">                    String columnName = updateItem.getColumnName().toLowerCase();</span>
<span class="fc" id="L298">                    Integer columnIndex = columnIndexMap.get(columnName);</span>
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">                    if (columnIndex == null) {</span>
<span class="nc" id="L300">                        throw new SqlExecutionException(&quot;Column not found: &quot; + columnName);</span>
                    }
                    
<span class="fc" id="L303">                    Object newValue = expressionEvaluator.evaluate(updateItem.getValue(), context);</span>
<span class="fc" id="L304">                    Column column = columns.get(columnIndex);</span>
                    
                    // Convert and validate value
<span class="fc" id="L307">                    newValue = column.getDataType().convertValue(newValue);</span>
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">                    if (!column.getDataType().isValidValue(newValue)) {</span>
<span class="nc" id="L309">                        throw new SqlExecutionException(&quot;Invalid value for column &quot; + </span>
                            columnName + &quot;: &quot; + newValue);
                    }
                    
<span class="fc" id="L313">                    newData[columnIndex] = newValue;</span>
<span class="fc" id="L314">                }</span>
                
                // Update the row
<span class="fc" id="L317">                table.updateRow(row.getId(), newData);</span>
<span class="fc" id="L318">                affectedRows++;</span>
<span class="fc" id="L319">            }</span>
            
<span class="fc" id="L321">            logger.debug(&quot;UPDATE executed: {} rows updated in {}&quot;, affectedRows, tableName);</span>
<span class="fc" id="L322">            return new SqlExecutionResult(SqlExecutionResult.ResultType.UPDATE, affectedRows);</span>
            
<span class="nc" id="L324">        } catch (Exception e) {</span>
<span class="nc" id="L325">            throw new SqlExecutionException(&quot;Failed to execute UPDATE statement&quot;, e);</span>
        }
    }
    
    @Override
    public SqlExecutionResult visitDeleteStatement(DeleteStatement node, ExecutionContext context) throws SqlExecutionException {
        try {
<span class="fc" id="L332">            String tableName = node.getTableName();</span>
<span class="fc" id="L333">            Table table = engine.getTable(&quot;public&quot;, tableName);</span>
<span class="pc bpc" id="L334" title="1 of 2 branches missed.">            if (table == null) {</span>
<span class="nc" id="L335">                throw new SqlExecutionException(&quot;Table not found: &quot; + tableName);</span>
            }
            
            // Get all rows and filter by WHERE clause if present
<span class="fc" id="L339">            List&lt;Row&gt; allRows = table.getAllRows();</span>
<span class="fc" id="L340">            List&lt;Row&gt; rowsToDelete = allRows;</span>
            
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">            if (node.getWhereClause().isPresent()) {</span>
<span class="fc" id="L343">                WhereClause whereClause = node.getWhereClause().get();</span>
<span class="fc" id="L344">                rowsToDelete = new ArrayList&lt;&gt;();</span>
                
<span class="fc bfc" id="L346" title="All 2 branches covered.">                for (Row row : allRows) {</span>
<span class="fc" id="L347">                    context.setCurrentRow(row);</span>
<span class="fc" id="L348">                    context.setCurrentTable(table);</span>
                    
<span class="fc" id="L350">                    Object result = expressionEvaluator.evaluate(whereClause.getCondition(), context);</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">                    if (Boolean.TRUE.equals(result)) {</span>
<span class="fc" id="L352">                        rowsToDelete.add(row);</span>
                    }
<span class="fc" id="L354">                }</span>
            }
            
<span class="fc" id="L357">            int affectedRows = 0;</span>
            
            // Delete matching rows
<span class="fc bfc" id="L360" title="All 2 branches covered.">            for (Row row : rowsToDelete) {</span>
<span class="pc bpc" id="L361" title="1 of 2 branches missed.">                if (table.deleteRow(row.getId())) {</span>
<span class="fc" id="L362">                    affectedRows++;</span>
                }
<span class="fc" id="L364">            }</span>
            
<span class="fc" id="L366">            logger.debug(&quot;DELETE executed: {} rows deleted from {}&quot;, affectedRows, tableName);</span>
<span class="fc" id="L367">            return new SqlExecutionResult(SqlExecutionResult.ResultType.DELETE, affectedRows);</span>
            
<span class="nc" id="L369">        } catch (Exception e) {</span>
<span class="nc" id="L370">            throw new SqlExecutionException(&quot;Failed to execute DELETE statement&quot;, e);</span>
        }
    }
    
    @Override
    public SqlExecutionResult visitCreateTableStatement(CreateTableStatement node, ExecutionContext context) throws SqlExecutionException {
        try {
<span class="fc" id="L377">            String tableName = node.getTableName();</span>
            
            // Build columns from column definitions
<span class="fc" id="L380">            List&lt;Column&gt; columns = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">            for (ColumnDefinition colDef : node.getColumnDefinitions()) {</span>
<span class="fc" id="L382">                String columnName = colDef.getColumnName();</span>
<span class="fc" id="L383">                DataType dataType = colDef.getDataType().getDataType();</span>
                
                // Check constraints (simplified - only handling NOT NULL for now)
<span class="fc bfc" id="L386" title="All 2 branches covered.">                boolean nullable = !colDef.getConstraints().contains(ColumnDefinition.Constraint.NOT_NULL);</span>
                
<span class="fc" id="L388">                columns.add(new Column.Builder()</span>
<span class="fc" id="L389">                    .name(columnName)</span>
<span class="fc" id="L390">                    .dataType(dataType)</span>
<span class="fc" id="L391">                    .nullable(nullable)</span>
<span class="fc" id="L392">                    .build());</span>
<span class="fc" id="L393">            }</span>
            
            // Create table
<span class="fc" id="L396">            Table table = new Table(tableName, columns);</span>
<span class="fc" id="L397">            boolean created = engine.createTable(&quot;public&quot;, table);</span>
            
<span class="pc bpc" id="L399" title="1 of 2 branches missed.">            if (created) {</span>
<span class="fc" id="L400">                logger.debug(&quot;CREATE TABLE executed: {} created&quot;, tableName);</span>
<span class="fc" id="L401">                return new SqlExecutionResult(SqlExecutionResult.ResultType.DDL, true, </span>
                    &quot;Table &quot; + tableName + &quot; created successfully&quot;);
            } else {
<span class="nc" id="L404">                return new SqlExecutionResult(SqlExecutionResult.ResultType.DDL, false, </span>
                    &quot;Table &quot; + tableName + &quot; already exists&quot;);
            }
            
<span class="nc" id="L408">        } catch (Exception e) {</span>
<span class="nc" id="L409">            throw new SqlExecutionException(&quot;Failed to execute CREATE TABLE statement&quot;, e);</span>
        }
    }
    
    @Override
    public SqlExecutionResult visitDropTableStatement(DropTableStatement node, ExecutionContext context) throws SqlExecutionException {
        try {
<span class="nc" id="L416">            String tableName = node.getTableName();</span>
            
            // For now, we don't have a direct dropTable method, so we'll simulate it
<span class="nc" id="L419">            Table table = engine.getTable(&quot;public&quot;, tableName);</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">            if (table == null) {</span>
<span class="nc" id="L421">                return new SqlExecutionResult(SqlExecutionResult.ResultType.DDL, false, </span>
                    &quot;Table &quot; + tableName + &quot; does not exist&quot;);
            }
            
            // TODO: Implement actual table dropping in the engine
<span class="nc" id="L426">            logger.debug(&quot;DROP TABLE executed: {} (simulated)&quot;, tableName);</span>
<span class="nc" id="L427">            return new SqlExecutionResult(SqlExecutionResult.ResultType.DDL, true, </span>
                &quot;Table &quot; + tableName + &quot; would be dropped (not implemented)&quot;);
            
<span class="nc" id="L430">        } catch (Exception e) {</span>
<span class="nc" id="L431">            throw new SqlExecutionException(&quot;Failed to execute DROP TABLE statement&quot;, e);</span>
        }
    }
    
    /**
     * Result of executing a FROM clause with potential joins.
     */
    private static class JoinResult {
        final List&lt;Column&gt; columns;
        final List&lt;Row&gt; rows;
        
<span class="fc" id="L442">        JoinResult(List&lt;Column&gt; columns, List&lt;Row&gt; rows) {</span>
<span class="fc" id="L443">            this.columns = columns;</span>
<span class="fc" id="L444">            this.rows = rows;</span>
<span class="fc" id="L445">        }</span>
    }
    
    /**
     * Execute the FROM clause, handling both simple table references and joins.
     */
    private JoinResult executeFromClause(FromClause fromClause, ExecutionContext context) throws SqlExecutionException {
<span class="fc" id="L452">        List&lt;JoinableTable&gt; joinableTables = fromClause.getJoinableTables();</span>
        
<span class="pc bpc" id="L454" title="1 of 2 branches missed.">        if (joinableTables.size() != 1) {</span>
<span class="nc" id="L455">            throw new SqlExecutionException(&quot;Multi-table FROM clause not yet supported&quot;);</span>
        }
        
<span class="fc" id="L458">        JoinableTable joinableTable = joinableTables.get(0);</span>
        
        // Get base table
<span class="fc" id="L461">        TableReference baseTableRef = joinableTable.getBaseTable();</span>
<span class="fc" id="L462">        String baseTableName = baseTableRef.getTableName();</span>
<span class="fc" id="L463">        Table baseTable = engine.getTable(&quot;public&quot;, baseTableName);</span>
<span class="fc bfc" id="L464" title="All 2 branches covered.">        if (baseTable == null) {</span>
<span class="fc" id="L465">            throw new SqlExecutionException(&quot;Table not found: &quot; + baseTableName);</span>
        }
        
        // Start with base table data
<span class="fc" id="L469">        List&lt;Column&gt; resultColumns = new ArrayList&lt;&gt;(baseTable.getColumns());</span>
<span class="fc" id="L470">        List&lt;Row&gt; resultRows = baseTable.getAllRows();</span>
        
        
        // Apply joins if present
<span class="fc bfc" id="L474" title="All 2 branches covered.">        if (joinableTable.hasJoins()) {</span>
<span class="fc" id="L475">            TableReference baseTableReference = baseTableRef; // Track the left table reference for alias support</span>
<span class="fc bfc" id="L476" title="All 2 branches covered.">            for (JoinClause joinClause : joinableTable.getJoins()) {</span>
<span class="fc" id="L477">                JoinResult joinResult = executeJoin(resultColumns, resultRows, joinClause, context, baseTableReference);</span>
<span class="fc" id="L478">                resultColumns = joinResult.columns;</span>
<span class="fc" id="L479">                resultRows = joinResult.rows;</span>
                // For subsequent joins, the left side becomes the previous join result
<span class="fc" id="L481">                baseTableReference = null; // No simple reference for joined result</span>
<span class="fc" id="L482">            }</span>
        }
        
<span class="fc" id="L485">        return new JoinResult(resultColumns, resultRows);</span>
    }
    
    /**
     * Execute a single join operation with optimization.
     */
    private JoinResult executeJoin(List&lt;Column&gt; leftColumns, List&lt;Row&gt; leftRows, 
                                  JoinClause joinClause, ExecutionContext context, TableReference leftTableRef) throws SqlExecutionException {
        
        // Get right table
<span class="fc" id="L495">        TableReference rightTableRef = joinClause.getTable();</span>
<span class="fc" id="L496">        String rightTableName = rightTableRef.getTableName();</span>
<span class="fc" id="L497">        Table rightTable = engine.getTable(&quot;public&quot;, rightTableName);</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">        if (rightTable == null) {</span>
<span class="fc" id="L499">            throw new SqlExecutionException(&quot;Table not found: &quot; + rightTableName);</span>
        }
        
<span class="fc" id="L502">        List&lt;Row&gt; rightRows = rightTable.getAllRows();</span>
<span class="fc" id="L503">        List&lt;Column&gt; rightColumns = rightTable.getColumns();</span>
        
        // Combine column schemas
<span class="fc" id="L506">        List&lt;Column&gt; combinedColumns = new ArrayList&lt;&gt;(leftColumns);</span>
<span class="fc" id="L507">        combinedColumns.addAll(rightColumns);</span>
        
        // Set up table information for proper column resolution
<span class="fc" id="L510">        Map&lt;String, List&lt;Column&gt;&gt; tableColumns = new HashMap&lt;&gt;();</span>
<span class="fc" id="L511">        List&lt;String&gt; tableOrder = new ArrayList&lt;&gt;();</span>
        
        // Add base table info (use alias if available)
<span class="pc bpc" id="L514" title="1 of 2 branches missed.">        if (leftTableRef != null) {</span>
<span class="fc bfc" id="L515" title="All 2 branches covered.">            String leftTableKey = leftTableRef.getAlias().isPresent() ?</span>
<span class="fc" id="L516">                leftTableRef.getAlias().get().toLowerCase() : leftTableRef.getTableName().toLowerCase();</span>
<span class="fc" id="L517">            tableColumns.put(leftTableKey, new ArrayList&lt;&gt;(leftColumns));</span>
<span class="fc" id="L518">            tableOrder.add(leftTableKey);</span>
        }
        
        // Add right table info (use alias if available)
<span class="fc bfc" id="L522" title="All 2 branches covered.">        String rightTableKey = rightTableRef.getAlias().isPresent() ? </span>
<span class="fc" id="L523">            rightTableRef.getAlias().get().toLowerCase() : rightTableName.toLowerCase();</span>
<span class="fc" id="L524">        tableColumns.put(rightTableKey, new ArrayList&lt;&gt;(rightColumns));</span>
<span class="fc" id="L525">        tableOrder.add(rightTableKey);</span>
        
        // Update context with table information
<span class="fc" id="L528">        context.setTableColumns(tableColumns);</span>
<span class="fc" id="L529">        context.setTableOrder(tableOrder);</span>
        
<span class="fc" id="L531">        List&lt;Row&gt; joinedRows = new ArrayList&lt;&gt;();</span>
        
        // Choose optimal join algorithm based on conditions and data size
<span class="fc" id="L534">        JoinAlgorithm algorithm = chooseOptimalJoinAlgorithm(</span>
<span class="fc" id="L535">            leftRows, rightRows, leftColumns, rightColumns, joinClause.getOnCondition()</span>
        );
        
<span class="fc" id="L538">        logger.debug(&quot;Using {} algorithm for {} join between {} and {} rows&quot;, </span>
<span class="fc" id="L539">                    algorithm, joinClause.getJoinType(), leftRows.size(), rightRows.size());</span>
        
        // Execute join based on join type and chosen algorithm
<span class="pc bpc" id="L542" title="1 of 5 branches missed.">        switch (joinClause.getJoinType()) {</span>
            case INNER:
<span class="fc" id="L544">                executeInnerJoinOptimized(leftRows, rightRows, leftColumns, rightColumns, </span>
<span class="fc" id="L545">                                        joinClause.getOnCondition(), combinedColumns, joinedRows, context, algorithm);</span>
<span class="fc" id="L546">                break;</span>
            case LEFT:
<span class="fc" id="L548">                executeLeftOuterJoinOptimized(leftRows, rightRows, leftColumns, rightColumns, </span>
<span class="fc" id="L549">                                            joinClause.getOnCondition(), combinedColumns, joinedRows, context, algorithm);</span>
<span class="fc" id="L550">                break;</span>
            case RIGHT:
<span class="fc" id="L552">                executeRightOuterJoinOptimized(leftRows, rightRows, leftColumns, rightColumns, </span>
<span class="fc" id="L553">                                             joinClause.getOnCondition(), combinedColumns, joinedRows, context, algorithm);</span>
<span class="fc" id="L554">                break;</span>
            case FULL_OUTER:
<span class="fc" id="L556">                executeFullOuterJoinOptimized(leftRows, rightRows, leftColumns, rightColumns, </span>
<span class="fc" id="L557">                                            joinClause.getOnCondition(), combinedColumns, joinedRows, context, algorithm);</span>
<span class="fc" id="L558">                break;</span>
            default:
<span class="nc" id="L560">                throw new SqlExecutionException(&quot;Unsupported join type: &quot; + joinClause.getJoinType());</span>
        }
        
<span class="fc" id="L563">        return new JoinResult(combinedColumns, joinedRows);</span>
    }
    
    
    /**
     * Available JOIN algorithms for optimization.
     */
<span class="fc" id="L570">    private enum JoinAlgorithm {</span>
<span class="fc" id="L571">        NESTED_LOOP,  // Original O(n*m) algorithm</span>
<span class="fc" id="L572">        HASH_JOIN,    // Hash-based join for equi-joins</span>
<span class="fc" id="L573">        SORT_MERGE    // Sort-merge join (future enhancement)</span>
    }
    
    /**
     * Choose optimal join algorithm based on data characteristics.
     */
    private JoinAlgorithm chooseOptimalJoinAlgorithm(List&lt;Row&gt; leftRows, List&lt;Row&gt; rightRows, 
                                                   List&lt;Column&gt; leftColumns, List&lt;Column&gt; rightColumns,
                                                   Optional&lt;Expression&gt; joinCondition) {
        
<span class="fc" id="L583">        int leftSize = leftRows.size();</span>
<span class="fc" id="L584">        int rightSize = rightRows.size();</span>
        
        // For small datasets (&lt; 100 rows each), nested loop is efficient due to simplicity
<span class="pc bpc" id="L587" title="2 of 4 branches missed.">        if (leftSize &lt; 100 &amp;&amp; rightSize &lt; 100) {</span>
<span class="fc" id="L588">            return JoinAlgorithm.NESTED_LOOP;</span>
        }
        
        // If we have a simple equi-join condition, prefer hash join for larger datasets
<span class="nc bnc" id="L592" title="All 4 branches missed.">        if (joinCondition.isPresent() &amp;&amp; isSimpleEquiJoin(joinCondition.get(), leftColumns, rightColumns)) {</span>
            // Hash join is particularly effective when one table is much smaller
<span class="nc bnc" id="L594" title="All 2 branches missed.">            if (Math.min(leftSize, rightSize) &lt; Math.max(leftSize, rightSize) / 3) {</span>
<span class="nc" id="L595">                return JoinAlgorithm.HASH_JOIN;</span>
            }
            // Also prefer hash join for medium-to-large datasets
<span class="nc bnc" id="L598" title="All 4 branches missed.">            if (leftSize &gt; 50 || rightSize &gt; 50) {</span>
<span class="nc" id="L599">                return JoinAlgorithm.HASH_JOIN;</span>
            }
        }
        
        // Default to nested loop for complex conditions or small datasets
<span class="nc" id="L604">        return JoinAlgorithm.NESTED_LOOP;</span>
    }
    
    /**
     * Check if the join condition is a simple equi-join (col1 = col2).
     */
    private boolean isSimpleEquiJoin(Expression condition, List&lt;Column&gt; leftColumns, List&lt;Column&gt; rightColumns) {
<span class="nc bnc" id="L611" title="All 2 branches missed.">        if (!(condition instanceof BinaryExpression)) {</span>
<span class="nc" id="L612">            return false;</span>
        }
        
<span class="nc" id="L615">        BinaryExpression binary = (BinaryExpression) condition;</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">        if (!&quot;=&quot;.equals(binary.getOperator())) {</span>
<span class="nc" id="L617">            return false;</span>
        }
        
        // Check if both sides are simple column references
<span class="nc bnc" id="L621" title="All 2 branches missed.">        return (binary.getLeft() instanceof ColumnReference) &amp;&amp; </span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">               (binary.getRight() instanceof ColumnReference);</span>
    }
    
    /**
     * Execute INNER JOIN operation with optimization.
     */
    private void executeInnerJoinOptimized(List&lt;Row&gt; leftRows, List&lt;Row&gt; rightRows,
                                         List&lt;Column&gt; leftColumns, List&lt;Column&gt; rightColumns,
                                         Optional&lt;Expression&gt; onCondition, List&lt;Column&gt; combinedColumns,
                                         List&lt;Row&gt; result, ExecutionContext context, JoinAlgorithm algorithm) throws SqlExecutionException {
        
<span class="pc bpc" id="L633" title="1 of 2 branches missed.">        switch (algorithm) {</span>
            case HASH_JOIN:
<span class="nc" id="L635">                executeHashInnerJoin(leftRows, rightRows, leftColumns, rightColumns, </span>
                                   onCondition, combinedColumns, result, context);
<span class="nc" id="L637">                break;</span>
            case NESTED_LOOP:
            default:
<span class="fc" id="L640">                executeNestedLoopInnerJoin(leftRows, rightRows, leftColumns, rightColumns, </span>
                                         onCondition, combinedColumns, result, context);
                break;
        }
<span class="fc" id="L644">    }</span>
    
    /**
     * Execute INNER JOIN using nested loop algorithm.
     */
    private void executeNestedLoopInnerJoin(List&lt;Row&gt; leftRows, List&lt;Row&gt; rightRows,
                                          List&lt;Column&gt; leftColumns, List&lt;Column&gt; rightColumns,
                                          Optional&lt;Expression&gt; onCondition, List&lt;Column&gt; combinedColumns,
                                          List&lt;Row&gt; result, ExecutionContext context) throws SqlExecutionException {
        
<span class="fc bfc" id="L654" title="All 2 branches covered.">        for (Row leftRow : leftRows) {</span>
<span class="fc bfc" id="L655" title="All 2 branches covered.">            for (Row rightRow : rightRows) {</span>
<span class="fc bfc" id="L656" title="All 2 branches covered.">                if (evaluateJoinCondition(leftRow, rightRow, leftColumns, rightColumns, </span>
                                        onCondition, combinedColumns, context)) {
<span class="fc" id="L658">                    Row joinedRow = combineRows(leftRow, rightRow);</span>
<span class="fc" id="L659">                    result.add(joinedRow);</span>
                }
<span class="fc" id="L661">            }</span>
<span class="fc" id="L662">        }</span>
<span class="fc" id="L663">    }</span>
    
    /**
     * Execute INNER JOIN using hash join algorithm for equi-joins.
     */
    private void executeHashInnerJoin(List&lt;Row&gt; leftRows, List&lt;Row&gt; rightRows,
                                    List&lt;Column&gt; leftColumns, List&lt;Column&gt; rightColumns,
                                    Optional&lt;Expression&gt; onCondition, List&lt;Column&gt; combinedColumns,
                                    List&lt;Row&gt; result, ExecutionContext context) throws SqlExecutionException {
        
<span class="nc bnc" id="L673" title="All 2 branches missed.">        if (!onCondition.isPresent()) {</span>
            // Fall back to nested loop for cross joins
<span class="nc" id="L675">            executeNestedLoopInnerJoin(leftRows, rightRows, leftColumns, rightColumns, </span>
                                     onCondition, combinedColumns, result, context);
<span class="nc" id="L677">            return;</span>
        }
        
        // Extract join keys from the equi-join condition
<span class="nc" id="L681">        JoinKeys joinKeys = extractJoinKeys(onCondition.get(), leftColumns, rightColumns);</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">        if (joinKeys == null) {</span>
            // Fall back to nested loop for complex conditions
<span class="nc" id="L684">            executeNestedLoopInnerJoin(leftRows, rightRows, leftColumns, rightColumns, </span>
                                     onCondition, combinedColumns, result, context);
<span class="nc" id="L686">            return;</span>
        }
        
        // Choose smaller table for building hash table
        List&lt;Row&gt; buildRows;
        List&lt;Row&gt; probeRows;
        int buildKeyIndex;
        int probeKeyIndex;
        boolean leftIsBuild;
        
<span class="nc bnc" id="L696" title="All 2 branches missed.">        if (leftRows.size() &lt;= rightRows.size()) {</span>
<span class="nc" id="L697">            buildRows = leftRows;</span>
<span class="nc" id="L698">            probeRows = rightRows;</span>
<span class="nc" id="L699">            buildKeyIndex = joinKeys.leftKeyIndex;</span>
<span class="nc" id="L700">            probeKeyIndex = joinKeys.rightKeyIndex;</span>
<span class="nc" id="L701">            leftIsBuild = true;</span>
        } else {
<span class="nc" id="L703">            buildRows = rightRows;</span>
<span class="nc" id="L704">            probeRows = leftRows;</span>
<span class="nc" id="L705">            buildKeyIndex = joinKeys.rightKeyIndex;</span>
<span class="nc" id="L706">            probeKeyIndex = joinKeys.leftKeyIndex;</span>
<span class="nc" id="L707">            leftIsBuild = false;</span>
        }
        
        // Build phase: create hash table
<span class="nc" id="L711">        Map&lt;Object, List&lt;Row&gt;&gt; hashTable = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">        for (Row buildRow : buildRows) {</span>
<span class="nc" id="L713">            Object key = buildRow.getData()[buildKeyIndex];</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">            if (key != null) { // Skip null keys</span>
<span class="nc" id="L715">                hashTable.computeIfAbsent(key, k -&gt; new ArrayList&lt;&gt;()).add(buildRow);</span>
            }
<span class="nc" id="L717">        }</span>
        
        // Probe phase: lookup and join
<span class="nc bnc" id="L720" title="All 2 branches missed.">        for (Row probeRow : probeRows) {</span>
<span class="nc" id="L721">            Object key = probeRow.getData()[probeKeyIndex];</span>
<span class="nc bnc" id="L722" title="All 2 branches missed.">            if (key != null) {</span>
<span class="nc" id="L723">                List&lt;Row&gt; matchingRows = hashTable.get(key);</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">                if (matchingRows != null) {</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">                    for (Row matchingRow : matchingRows) {</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">                        Row joinedRow = leftIsBuild ? </span>
<span class="nc" id="L727">                            combineRows(matchingRow, probeRow) :</span>
<span class="nc" id="L728">                            combineRows(probeRow, matchingRow);</span>
<span class="nc" id="L729">                        result.add(joinedRow);</span>
<span class="nc" id="L730">                    }</span>
                }
            }
<span class="nc" id="L733">        }</span>
<span class="nc" id="L734">    }</span>
    
    /**
     * Helper class to hold join key information.
     */
    private static class JoinKeys {
        final int leftKeyIndex;
        final int rightKeyIndex;
        
<span class="nc" id="L743">        JoinKeys(int leftKeyIndex, int rightKeyIndex) {</span>
<span class="nc" id="L744">            this.leftKeyIndex = leftKeyIndex;</span>
<span class="nc" id="L745">            this.rightKeyIndex = rightKeyIndex;</span>
<span class="nc" id="L746">        }</span>
    }
    
    /**
     * Extract join keys from equi-join condition.
     */
    private JoinKeys extractJoinKeys(Expression condition, List&lt;Column&gt; leftColumns, List&lt;Column&gt; rightColumns) {
<span class="nc bnc" id="L753" title="All 2 branches missed.">        if (!(condition instanceof BinaryExpression)) {</span>
<span class="nc" id="L754">            return null;</span>
        }
        
<span class="nc" id="L757">        BinaryExpression binary = (BinaryExpression) condition;</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">        if (!&quot;=&quot;.equals(binary.getOperator())) {</span>
<span class="nc" id="L759">            return null;</span>
        }
        
<span class="nc" id="L762">        Expression left = binary.getLeft();</span>
<span class="nc" id="L763">        Expression right = binary.getRight();</span>
        
<span class="nc bnc" id="L765" title="All 4 branches missed.">        if (!(left instanceof ColumnReference) || !(right instanceof ColumnReference)) {</span>
<span class="nc" id="L766">            return null;</span>
        }
        
<span class="nc" id="L769">        ColumnReference leftCol = (ColumnReference) left;</span>
<span class="nc" id="L770">        ColumnReference rightCol = (ColumnReference) right;</span>
        
        // Find column indexes
<span class="nc" id="L773">        Integer leftIndex = findColumnIndex(leftCol.getColumnName(), leftColumns);</span>
<span class="nc" id="L774">        Integer rightIndex = findColumnIndex(rightCol.getColumnName(), rightColumns);</span>
        
<span class="nc bnc" id="L776" title="All 4 branches missed.">        if (leftIndex != null &amp;&amp; rightIndex != null) {</span>
<span class="nc" id="L777">            return new JoinKeys(leftIndex, rightIndex + leftColumns.size());</span>
        }
        
        // Try the reverse (right column might be from left table)
<span class="nc" id="L781">        rightIndex = findColumnIndex(leftCol.getColumnName(), rightColumns);</span>
<span class="nc" id="L782">        leftIndex = findColumnIndex(rightCol.getColumnName(), leftColumns);</span>
        
<span class="nc bnc" id="L784" title="All 4 branches missed.">        if (leftIndex != null &amp;&amp; rightIndex != null) {</span>
<span class="nc" id="L785">            return new JoinKeys(leftIndex, rightIndex + leftColumns.size());</span>
        }
        
<span class="nc" id="L788">        return null;</span>
    }
    
    /**
     * Find column index by name.
     */
    private Integer findColumnIndex(String columnName, List&lt;Column&gt; columns) {
<span class="nc bnc" id="L795" title="All 2 branches missed.">        for (int i = 0; i &lt; columns.size(); i++) {</span>
<span class="nc bnc" id="L796" title="All 2 branches missed.">            if (columns.get(i).getName().equalsIgnoreCase(columnName)) {</span>
<span class="nc" id="L797">                return i;</span>
            }
        }
<span class="nc" id="L800">        return null;</span>
    }
    
    /**
     * Execute LEFT OUTER JOIN operation with optimization.
     */
    private void executeLeftOuterJoinOptimized(List&lt;Row&gt; leftRows, List&lt;Row&gt; rightRows,
                                             List&lt;Column&gt; leftColumns, List&lt;Column&gt; rightColumns,
                                             Optional&lt;Expression&gt; onCondition, List&lt;Column&gt; combinedColumns,
                                             List&lt;Row&gt; result, ExecutionContext context, JoinAlgorithm algorithm) throws SqlExecutionException {
        
<span class="pc bpc" id="L811" title="1 of 2 branches missed.">        switch (algorithm) {</span>
            case HASH_JOIN:
<span class="nc" id="L813">                executeHashLeftOuterJoin(leftRows, rightRows, leftColumns, rightColumns, </span>
                                       onCondition, combinedColumns, result, context);
<span class="nc" id="L815">                break;</span>
            case NESTED_LOOP:
            default:
<span class="fc" id="L818">                executeNestedLoopLeftOuterJoin(leftRows, rightRows, leftColumns, rightColumns, </span>
                                             onCondition, combinedColumns, result, context);
                break;
        }
<span class="fc" id="L822">    }</span>
    
    /**
     * Execute LEFT OUTER JOIN using nested loop algorithm.
     */
    private void executeNestedLoopLeftOuterJoin(List&lt;Row&gt; leftRows, List&lt;Row&gt; rightRows,
                                              List&lt;Column&gt; leftColumns, List&lt;Column&gt; rightColumns,
                                              Optional&lt;Expression&gt; onCondition, List&lt;Column&gt; combinedColumns,
                                              List&lt;Row&gt; result, ExecutionContext context) throws SqlExecutionException {
        
<span class="fc bfc" id="L832" title="All 2 branches covered.">        for (Row leftRow : leftRows) {</span>
<span class="fc" id="L833">            boolean hasMatch = false;</span>
            
<span class="fc bfc" id="L835" title="All 2 branches covered.">            for (Row rightRow : rightRows) {</span>
<span class="fc bfc" id="L836" title="All 2 branches covered.">                if (evaluateJoinCondition(leftRow, rightRow, leftColumns, rightColumns, </span>
                                        onCondition, combinedColumns, context)) {
<span class="fc" id="L838">                    Row joinedRow = combineRows(leftRow, rightRow);</span>
<span class="fc" id="L839">                    result.add(joinedRow);</span>
<span class="fc" id="L840">                    hasMatch = true;</span>
                }
<span class="fc" id="L842">            }</span>
            
            // If no match found, add left row with nulls for right columns
<span class="fc bfc" id="L845" title="All 2 branches covered.">            if (!hasMatch) {</span>
<span class="fc" id="L846">                Row nullRightRow = createNullRow(rightColumns.size());</span>
<span class="fc" id="L847">                Row joinedRow = combineRows(leftRow, nullRightRow);</span>
<span class="fc" id="L848">                result.add(joinedRow);</span>
            }
<span class="fc" id="L850">        }</span>
<span class="fc" id="L851">    }</span>
    
    /**
     * Execute LEFT OUTER JOIN using hash join algorithm for equi-joins.
     */
    private void executeHashLeftOuterJoin(List&lt;Row&gt; leftRows, List&lt;Row&gt; rightRows,
                                        List&lt;Column&gt; leftColumns, List&lt;Column&gt; rightColumns,
                                        Optional&lt;Expression&gt; onCondition, List&lt;Column&gt; combinedColumns,
                                        List&lt;Row&gt; result, ExecutionContext context) throws SqlExecutionException {
        
<span class="nc bnc" id="L861" title="All 2 branches missed.">        if (!onCondition.isPresent()) {</span>
            // Fall back to nested loop for cross joins
<span class="nc" id="L863">            executeNestedLoopLeftOuterJoin(leftRows, rightRows, leftColumns, rightColumns, </span>
                                         onCondition, combinedColumns, result, context);
<span class="nc" id="L865">            return;</span>
        }
        
        // Extract join keys from the equi-join condition
<span class="nc" id="L869">        JoinKeys joinKeys = extractJoinKeys(onCondition.get(), leftColumns, rightColumns);</span>
<span class="nc bnc" id="L870" title="All 2 branches missed.">        if (joinKeys == null) {</span>
            // Fall back to nested loop for complex conditions
<span class="nc" id="L872">            executeNestedLoopLeftOuterJoin(leftRows, rightRows, leftColumns, rightColumns, </span>
                                         onCondition, combinedColumns, result, context);
<span class="nc" id="L874">            return;</span>
        }
        
        // Build hash table from right table (probe side)
<span class="nc" id="L878">        Map&lt;Object, List&lt;Row&gt;&gt; hashTable = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L879" title="All 2 branches missed.">        for (Row rightRow : rightRows) {</span>
<span class="nc" id="L880">            Object key = rightRow.getData()[joinKeys.rightKeyIndex];</span>
<span class="nc bnc" id="L881" title="All 2 branches missed.">            if (key != null) { // Skip null keys</span>
<span class="nc" id="L882">                hashTable.computeIfAbsent(key, k -&gt; new ArrayList&lt;&gt;()).add(rightRow);</span>
            }
<span class="nc" id="L884">        }</span>
        
        // Probe with left table and preserve all left rows
<span class="nc bnc" id="L887" title="All 2 branches missed.">        for (Row leftRow : leftRows) {</span>
<span class="nc" id="L888">            Object key = leftRow.getData()[joinKeys.leftKeyIndex];</span>
<span class="nc bnc" id="L889" title="All 2 branches missed.">            List&lt;Row&gt; matchingRows = (key != null) ? hashTable.get(key) : null;</span>
            
<span class="nc bnc" id="L891" title="All 4 branches missed.">            if (matchingRows != null &amp;&amp; !matchingRows.isEmpty()) {</span>
                // Found matches, add all combinations
<span class="nc bnc" id="L893" title="All 2 branches missed.">                for (Row rightRow : matchingRows) {</span>
<span class="nc" id="L894">                    Row joinedRow = combineRows(leftRow, rightRow);</span>
<span class="nc" id="L895">                    result.add(joinedRow);</span>
<span class="nc" id="L896">                }</span>
            } else {
                // No match found, add left row with nulls for right columns
<span class="nc" id="L899">                Row nullRightRow = createNullRow(rightColumns.size());</span>
<span class="nc" id="L900">                Row joinedRow = combineRows(leftRow, nullRightRow);</span>
<span class="nc" id="L901">                result.add(joinedRow);</span>
            }
<span class="nc" id="L903">        }</span>
<span class="nc" id="L904">    }</span>
    
    /**
     * Execute RIGHT OUTER JOIN operation with optimization.
     */
    private void executeRightOuterJoinOptimized(List&lt;Row&gt; leftRows, List&lt;Row&gt; rightRows,
                                               List&lt;Column&gt; leftColumns, List&lt;Column&gt; rightColumns,
                                               Optional&lt;Expression&gt; onCondition, List&lt;Column&gt; combinedColumns,
                                               List&lt;Row&gt; result, ExecutionContext context, JoinAlgorithm algorithm) throws SqlExecutionException {
        
<span class="pc bpc" id="L914" title="1 of 2 branches missed.">        switch (algorithm) {</span>
            case HASH_JOIN:
<span class="nc" id="L916">                executeHashRightOuterJoin(leftRows, rightRows, leftColumns, rightColumns, </span>
                                        onCondition, combinedColumns, result, context);
<span class="nc" id="L918">                break;</span>
            case NESTED_LOOP:
            default:
<span class="fc" id="L921">                executeNestedLoopRightOuterJoin(leftRows, rightRows, leftColumns, rightColumns, </span>
                                              onCondition, combinedColumns, result, context);
                break;
        }
<span class="fc" id="L925">    }</span>
    
    /**
     * Execute RIGHT OUTER JOIN using nested loop algorithm.
     */
    private void executeNestedLoopRightOuterJoin(List&lt;Row&gt; leftRows, List&lt;Row&gt; rightRows,
                                                List&lt;Column&gt; leftColumns, List&lt;Column&gt; rightColumns,
                                                Optional&lt;Expression&gt; onCondition, List&lt;Column&gt; combinedColumns,
                                                List&lt;Row&gt; result, ExecutionContext context) throws SqlExecutionException {
        
<span class="fc bfc" id="L935" title="All 2 branches covered.">        for (Row rightRow : rightRows) {</span>
<span class="fc" id="L936">            boolean hasMatch = false;</span>
            
<span class="fc bfc" id="L938" title="All 2 branches covered.">            for (Row leftRow : leftRows) {</span>
<span class="fc bfc" id="L939" title="All 2 branches covered.">                if (evaluateJoinCondition(leftRow, rightRow, leftColumns, rightColumns, </span>
                                        onCondition, combinedColumns, context)) {
<span class="fc" id="L941">                    Row joinedRow = combineRows(leftRow, rightRow);</span>
<span class="fc" id="L942">                    result.add(joinedRow);</span>
<span class="fc" id="L943">                    hasMatch = true;</span>
                }
<span class="fc" id="L945">            }</span>
            
            // If no match found, add right row with nulls for left columns
<span class="fc bfc" id="L948" title="All 2 branches covered.">            if (!hasMatch) {</span>
<span class="fc" id="L949">                Row nullLeftRow = createNullRow(leftColumns.size());</span>
<span class="fc" id="L950">                Row joinedRow = combineRows(nullLeftRow, rightRow);</span>
<span class="fc" id="L951">                result.add(joinedRow);</span>
            }
<span class="fc" id="L953">        }</span>
<span class="fc" id="L954">    }</span>
    
    /**
     * Execute RIGHT OUTER JOIN using hash join algorithm for equi-joins.
     */
    private void executeHashRightOuterJoin(List&lt;Row&gt; leftRows, List&lt;Row&gt; rightRows,
                                         List&lt;Column&gt; leftColumns, List&lt;Column&gt; rightColumns,
                                         Optional&lt;Expression&gt; onCondition, List&lt;Column&gt; combinedColumns,
                                         List&lt;Row&gt; result, ExecutionContext context) throws SqlExecutionException {
        
<span class="nc bnc" id="L964" title="All 2 branches missed.">        if (!onCondition.isPresent()) {</span>
            // Fall back to nested loop for cross joins
<span class="nc" id="L966">            executeNestedLoopRightOuterJoin(leftRows, rightRows, leftColumns, rightColumns, </span>
                                          onCondition, combinedColumns, result, context);
<span class="nc" id="L968">            return;</span>
        }
        
        // Extract join keys from the equi-join condition
<span class="nc" id="L972">        JoinKeys joinKeys = extractJoinKeys(onCondition.get(), leftColumns, rightColumns);</span>
<span class="nc bnc" id="L973" title="All 2 branches missed.">        if (joinKeys == null) {</span>
            // Fall back to nested loop for complex conditions
<span class="nc" id="L975">            executeNestedLoopRightOuterJoin(leftRows, rightRows, leftColumns, rightColumns, </span>
                                          onCondition, combinedColumns, result, context);
<span class="nc" id="L977">            return;</span>
        }
        
        // Build hash table from left table
<span class="nc" id="L981">        Map&lt;Object, List&lt;Row&gt;&gt; hashTable = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L982" title="All 2 branches missed.">        for (Row leftRow : leftRows) {</span>
<span class="nc" id="L983">            Object key = leftRow.getData()[joinKeys.leftKeyIndex];</span>
<span class="nc bnc" id="L984" title="All 2 branches missed.">            if (key != null) { // Skip null keys</span>
<span class="nc" id="L985">                hashTable.computeIfAbsent(key, k -&gt; new ArrayList&lt;&gt;()).add(leftRow);</span>
            }
<span class="nc" id="L987">        }</span>
        
        // Probe with right table and preserve all right rows
<span class="nc bnc" id="L990" title="All 2 branches missed.">        for (Row rightRow : rightRows) {</span>
<span class="nc" id="L991">            Object key = rightRow.getData()[joinKeys.rightKeyIndex];</span>
<span class="nc bnc" id="L992" title="All 2 branches missed.">            List&lt;Row&gt; matchingRows = (key != null) ? hashTable.get(key) : null;</span>
            
<span class="nc bnc" id="L994" title="All 4 branches missed.">            if (matchingRows != null &amp;&amp; !matchingRows.isEmpty()) {</span>
                // Found matches, add all combinations
<span class="nc bnc" id="L996" title="All 2 branches missed.">                for (Row leftRow : matchingRows) {</span>
<span class="nc" id="L997">                    Row joinedRow = combineRows(leftRow, rightRow);</span>
<span class="nc" id="L998">                    result.add(joinedRow);</span>
<span class="nc" id="L999">                }</span>
            } else {
                // No match found, add right row with nulls for left columns
<span class="nc" id="L1002">                Row nullLeftRow = createNullRow(leftColumns.size());</span>
<span class="nc" id="L1003">                Row joinedRow = combineRows(nullLeftRow, rightRow);</span>
<span class="nc" id="L1004">                result.add(joinedRow);</span>
            }
<span class="nc" id="L1006">        }</span>
<span class="nc" id="L1007">    }</span>
    
    /**
     * Execute FULL OUTER JOIN operation with optimization.
     */
    private void executeFullOuterJoinOptimized(List&lt;Row&gt; leftRows, List&lt;Row&gt; rightRows,
                                              List&lt;Column&gt; leftColumns, List&lt;Column&gt; rightColumns,
                                              Optional&lt;Expression&gt; onCondition, List&lt;Column&gt; combinedColumns,
                                              List&lt;Row&gt; result, ExecutionContext context, JoinAlgorithm algorithm) throws SqlExecutionException {
        
<span class="pc bpc" id="L1017" title="1 of 2 branches missed.">        switch (algorithm) {</span>
            case HASH_JOIN:
<span class="nc" id="L1019">                executeHashFullOuterJoin(leftRows, rightRows, leftColumns, rightColumns, </span>
                                       onCondition, combinedColumns, result, context);
<span class="nc" id="L1021">                break;</span>
            case NESTED_LOOP:
            default:
<span class="fc" id="L1024">                executeNestedLoopFullOuterJoin(leftRows, rightRows, leftColumns, rightColumns, </span>
                                             onCondition, combinedColumns, result, context);
                break;
        }
<span class="fc" id="L1028">    }</span>
    
    /**
     * Execute FULL OUTER JOIN using nested loop algorithm.
     */
    private void executeNestedLoopFullOuterJoin(List&lt;Row&gt; leftRows, List&lt;Row&gt; rightRows,
                                               List&lt;Column&gt; leftColumns, List&lt;Column&gt; rightColumns,
                                               Optional&lt;Expression&gt; onCondition, List&lt;Column&gt; combinedColumns,
                                               List&lt;Row&gt; result, ExecutionContext context) throws SqlExecutionException {
        
<span class="fc" id="L1038">        Set&lt;Row&gt; matchedRightRows = new HashSet&lt;&gt;();</span>
        
        // First pass: find all matches and left outer join
<span class="fc bfc" id="L1041" title="All 2 branches covered.">        for (Row leftRow : leftRows) {</span>
<span class="fc" id="L1042">            boolean hasMatch = false;</span>
            
<span class="fc bfc" id="L1044" title="All 2 branches covered.">            for (Row rightRow : rightRows) {</span>
<span class="fc bfc" id="L1045" title="All 2 branches covered.">                if (evaluateJoinCondition(leftRow, rightRow, leftColumns, rightColumns, </span>
                                        onCondition, combinedColumns, context)) {
<span class="fc" id="L1047">                    Row joinedRow = combineRows(leftRow, rightRow);</span>
<span class="fc" id="L1048">                    result.add(joinedRow);</span>
<span class="fc" id="L1049">                    matchedRightRows.add(rightRow);</span>
<span class="fc" id="L1050">                    hasMatch = true;</span>
                }
<span class="fc" id="L1052">            }</span>
            
            // If no match found, add left row with nulls for right columns
<span class="fc bfc" id="L1055" title="All 2 branches covered.">            if (!hasMatch) {</span>
<span class="fc" id="L1056">                Row nullRightRow = createNullRow(rightColumns.size());</span>
<span class="fc" id="L1057">                Row joinedRow = combineRows(leftRow, nullRightRow);</span>
<span class="fc" id="L1058">                result.add(joinedRow);</span>
            }
<span class="fc" id="L1060">        }</span>
        
        // Second pass: add unmatched right rows
<span class="fc bfc" id="L1063" title="All 2 branches covered.">        for (Row rightRow : rightRows) {</span>
<span class="fc bfc" id="L1064" title="All 2 branches covered.">            if (!matchedRightRows.contains(rightRow)) {</span>
<span class="fc" id="L1065">                Row nullLeftRow = createNullRow(leftColumns.size());</span>
<span class="fc" id="L1066">                Row joinedRow = combineRows(nullLeftRow, rightRow);</span>
<span class="fc" id="L1067">                result.add(joinedRow);</span>
            }
<span class="fc" id="L1069">        }</span>
<span class="fc" id="L1070">    }</span>
    
    /**
     * Execute FULL OUTER JOIN using hash join algorithm for equi-joins.
     */
    private void executeHashFullOuterJoin(List&lt;Row&gt; leftRows, List&lt;Row&gt; rightRows,
                                        List&lt;Column&gt; leftColumns, List&lt;Column&gt; rightColumns,
                                        Optional&lt;Expression&gt; onCondition, List&lt;Column&gt; combinedColumns,
                                        List&lt;Row&gt; result, ExecutionContext context) throws SqlExecutionException {
        
<span class="nc bnc" id="L1080" title="All 2 branches missed.">        if (!onCondition.isPresent()) {</span>
            // Fall back to nested loop for cross joins
<span class="nc" id="L1082">            executeNestedLoopFullOuterJoin(leftRows, rightRows, leftColumns, rightColumns, </span>
                                         onCondition, combinedColumns, result, context);
<span class="nc" id="L1084">            return;</span>
        }
        
        // Extract join keys from the equi-join condition
<span class="nc" id="L1088">        JoinKeys joinKeys = extractJoinKeys(onCondition.get(), leftColumns, rightColumns);</span>
<span class="nc bnc" id="L1089" title="All 2 branches missed.">        if (joinKeys == null) {</span>
            // Fall back to nested loop for complex conditions
<span class="nc" id="L1091">            executeNestedLoopFullOuterJoin(leftRows, rightRows, leftColumns, rightColumns, </span>
                                         onCondition, combinedColumns, result, context);
<span class="nc" id="L1093">            return;</span>
        }
        
        // Build hash table from smaller table
<span class="nc" id="L1097">        Map&lt;Object, List&lt;Row&gt;&gt; leftHashTable = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1098" title="All 2 branches missed.">        for (Row leftRow : leftRows) {</span>
<span class="nc" id="L1099">            Object key = leftRow.getData()[joinKeys.leftKeyIndex];</span>
<span class="nc bnc" id="L1100" title="All 2 branches missed.">            if (key != null) {</span>
<span class="nc" id="L1101">                leftHashTable.computeIfAbsent(key, k -&gt; new ArrayList&lt;&gt;()).add(leftRow);</span>
            }
<span class="nc" id="L1103">        }</span>
        
<span class="nc" id="L1105">        Set&lt;Object&gt; matchedKeys = new HashSet&lt;&gt;();</span>
        
        // Process right table: find matches and add unmatched rights
<span class="nc bnc" id="L1108" title="All 2 branches missed.">        for (Row rightRow : rightRows) {</span>
<span class="nc" id="L1109">            Object key = rightRow.getData()[joinKeys.rightKeyIndex];</span>
<span class="nc bnc" id="L1110" title="All 2 branches missed.">            List&lt;Row&gt; matchingLeftRows = (key != null) ? leftHashTable.get(key) : null;</span>
            
<span class="nc bnc" id="L1112" title="All 4 branches missed.">            if (matchingLeftRows != null &amp;&amp; !matchingLeftRows.isEmpty()) {</span>
                // Found matches
<span class="nc" id="L1114">                matchedKeys.add(key);</span>
<span class="nc bnc" id="L1115" title="All 2 branches missed.">                for (Row leftRow : matchingLeftRows) {</span>
<span class="nc" id="L1116">                    Row joinedRow = combineRows(leftRow, rightRow);</span>
<span class="nc" id="L1117">                    result.add(joinedRow);</span>
<span class="nc" id="L1118">                }</span>
            } else {
                // No match found, add right row with nulls for left columns
<span class="nc" id="L1121">                Row nullLeftRow = createNullRow(leftColumns.size());</span>
<span class="nc" id="L1122">                Row joinedRow = combineRows(nullLeftRow, rightRow);</span>
<span class="nc" id="L1123">                result.add(joinedRow);</span>
            }
<span class="nc" id="L1125">        }</span>
        
        // Add unmatched left rows
<span class="nc bnc" id="L1128" title="All 2 branches missed.">        for (Row leftRow : leftRows) {</span>
<span class="nc" id="L1129">            Object key = leftRow.getData()[joinKeys.leftKeyIndex];</span>
<span class="nc bnc" id="L1130" title="All 4 branches missed.">            if (key == null || !matchedKeys.contains(key)) {</span>
<span class="nc" id="L1131">                Row nullRightRow = createNullRow(rightColumns.size());</span>
<span class="nc" id="L1132">                Row joinedRow = combineRows(leftRow, nullRightRow);</span>
<span class="nc" id="L1133">                result.add(joinedRow);</span>
            }
<span class="nc" id="L1135">        }</span>
<span class="nc" id="L1136">    }</span>
    
    /**
     * Evaluate join condition between two rows.
     */
    private boolean evaluateJoinCondition(Row leftRow, Row rightRow, 
                                        List&lt;Column&gt; leftColumns, List&lt;Column&gt; rightColumns,
                                        Optional&lt;Expression&gt; onCondition, List&lt;Column&gt; combinedColumns,
                                        ExecutionContext context) throws SqlExecutionException {
<span class="pc bpc" id="L1145" title="1 of 2 branches missed.">        if (!onCondition.isPresent()) {</span>
            // Cross join - always true
<span class="nc" id="L1147">            return true;</span>
        }
        
        // Create combined row for condition evaluation
<span class="fc" id="L1151">        Row combinedRow = combineRows(leftRow, rightRow);</span>
<span class="fc" id="L1152">        context.setCurrentRow(combinedRow);</span>
<span class="fc" id="L1153">        context.setJoinedColumns(combinedColumns);</span>
        
<span class="fc" id="L1155">        Object result = expressionEvaluator.evaluate(onCondition.get(), context);</span>
<span class="fc" id="L1156">        return Boolean.TRUE.equals(result);</span>
    }
    
    /**
     * Combine two rows into a single row.
     */
    private Row combineRows(Row leftRow, Row rightRow) {
<span class="fc" id="L1163">        Object[] leftData = leftRow.getData();</span>
<span class="fc" id="L1164">        Object[] rightData = rightRow.getData();</span>
        
<span class="fc" id="L1166">        Object[] combinedData = new Object[leftData.length + rightData.length];</span>
<span class="fc" id="L1167">        System.arraycopy(leftData, 0, combinedData, 0, leftData.length);</span>
<span class="fc" id="L1168">        System.arraycopy(rightData, 0, combinedData, leftData.length, rightData.length);</span>
        
<span class="fc" id="L1170">        return new Row(leftRow.getId(), combinedData);</span>
    }
    
    /**
     * Create a row with all null values for outer join.
     */
    private Row createNullRow(int columnCount) {
<span class="fc" id="L1177">        Object[] nullData = new Object[columnCount];</span>
<span class="fc" id="L1178">        Arrays.fill(nullData, null);</span>
<span class="fc" id="L1179">        return new Row(0L, nullData);</span>
    }

    // Helper methods
    private List&lt;Row&gt; applyOrderBy(List&lt;Row&gt; rows, OrderByClause orderBy, 
                                  ExecutionContext context, List&lt;Column&gt; columns) {
<span class="fc" id="L1185">        return rows.stream()</span>
<span class="fc" id="L1186">            .sorted((row1, row2) -&gt; {</span>
<span class="pc bpc" id="L1187" title="1 of 2 branches missed.">                for (OrderByClause.OrderItem item : orderBy.getOrderItems()) {</span>
<span class="fc" id="L1188">                    context.setCurrentRow(row1);</span>
<span class="fc" id="L1189">                    context.setJoinedColumns(columns);</span>
<span class="fc" id="L1190">                    Object value1 = expressionEvaluator.evaluate(item.getExpression(), context);</span>
                    
<span class="fc" id="L1192">                    context.setCurrentRow(row2);</span>
<span class="fc" id="L1193">                    context.setJoinedColumns(columns);</span>
<span class="fc" id="L1194">                    Object value2 = expressionEvaluator.evaluate(item.getExpression(), context);</span>
                    
<span class="fc" id="L1196">                    int comparison = compareValues(value1, value2);</span>
<span class="pc bpc" id="L1197" title="1 of 2 branches missed.">                    if (comparison != 0) {</span>
<span class="fc bfc" id="L1198" title="All 2 branches covered.">                        return item.isAscending() ? comparison : -comparison;</span>
                    }
<span class="nc" id="L1200">                }</span>
<span class="nc" id="L1201">                return 0;</span>
            })
<span class="fc" id="L1203">            .collect(Collectors.toList());</span>
    }
    
    private int evaluateIntExpression(Expression expr, ExecutionContext context) {
<span class="fc" id="L1207">        Object result = expressionEvaluator.evaluate(expr, context);</span>
<span class="pc bpc" id="L1208" title="1 of 2 branches missed.">        if (result instanceof Number) {</span>
<span class="fc" id="L1209">            return ((Number) result).intValue();</span>
        }
<span class="nc" id="L1211">        throw new IllegalArgumentException(&quot;Expression does not evaluate to a number: &quot; + result);</span>
    }
    
    @SuppressWarnings(&quot;unchecked&quot;)
    private int compareValues(Object value1, Object value2) {
<span class="pc bpc" id="L1216" title="3 of 4 branches missed.">        if (value1 == null &amp;&amp; value2 == null) return 0;</span>
<span class="pc bpc" id="L1217" title="1 of 2 branches missed.">        if (value1 == null) return -1;</span>
<span class="pc bpc" id="L1218" title="1 of 2 branches missed.">        if (value2 == null) return 1;</span>
        
<span class="pc bpc" id="L1220" title="2 of 4 branches missed.">        if (value1 instanceof Comparable &amp;&amp; value2 instanceof Comparable) {</span>
            try {
<span class="fc" id="L1222">                return ((Comparable) value1).compareTo(value2);</span>
<span class="nc" id="L1223">            } catch (ClassCastException e) {</span>
                // Fall back to string comparison
<span class="nc" id="L1225">                return value1.toString().compareTo(value2.toString());</span>
            }
        }
        
<span class="nc" id="L1229">        return value1.toString().compareTo(value2.toString());</span>
    }
    
    /**
     * Validate that all column references in an expression exist in the given columns.
     */
    private void validateColumnReferences(Expression expression, List&lt;Column&gt; columns) throws SqlExecutionException {
<span class="fc bfc" id="L1236" title="All 2 branches covered.">        if (expression instanceof ColumnReference) {</span>
<span class="fc" id="L1237">            ColumnReference colRef = (ColumnReference) expression;</span>
<span class="fc" id="L1238">            String columnName = colRef.getColumnName().toLowerCase();</span>
            
<span class="fc" id="L1240">            boolean found = columns.stream()</span>
<span class="fc" id="L1241">                .anyMatch(col -&gt; col.getName().toLowerCase().equals(columnName));</span>
            
<span class="fc bfc" id="L1243" title="All 2 branches covered.">            if (!found) {</span>
<span class="fc" id="L1244">                throw new SqlExecutionException(&quot;Column not found: &quot; + columnName);</span>
            }
<span class="fc" id="L1246">        }</span>
<span class="pc bpc" id="L1247" title="1 of 2 branches missed.">        else if (expression instanceof BinaryExpression) {</span>
<span class="nc" id="L1248">            BinaryExpression binary = (BinaryExpression) expression;</span>
<span class="nc" id="L1249">            validateColumnReferences(binary.getLeft(), columns);</span>
<span class="nc" id="L1250">            validateColumnReferences(binary.getRight(), columns);</span>
<span class="nc" id="L1251">        }</span>
<span class="pc bpc" id="L1252" title="1 of 2 branches missed.">        else if (expression instanceof UnaryExpression) {</span>
<span class="nc" id="L1253">            UnaryExpression unary = (UnaryExpression) expression;</span>
<span class="nc" id="L1254">            validateColumnReferences(unary.getOperand(), columns);</span>
<span class="nc" id="L1255">        }</span>
<span class="pc bpc" id="L1256" title="1 of 2 branches missed.">        else if (expression instanceof FunctionCall) {</span>
<span class="nc" id="L1257">            FunctionCall func = (FunctionCall) expression;</span>
<span class="nc bnc" id="L1258" title="All 2 branches missed.">            for (Expression arg : func.getArguments()) {</span>
<span class="nc" id="L1259">                validateColumnReferences(arg, columns);</span>
<span class="nc" id="L1260">            }</span>
        }
        // LiteralExpression and other types don't contain column references
<span class="fc" id="L1263">    }</span>
    
    // Unimplemented visitor methods for AST nodes that don't require direct execution
<span class="nc" id="L1266">    @Override public SqlExecutionResult visitJoinableTable(JoinableTable node, ExecutionContext context) { return null; }</span>
<span class="nc" id="L1267">    @Override public SqlExecutionResult visitLiteralExpression(LiteralExpression node, ExecutionContext context) { return null; }</span>
<span class="nc" id="L1268">    @Override public SqlExecutionResult visitColumnReference(ColumnReference node, ExecutionContext context) { return null; }</span>
<span class="nc" id="L1269">    @Override public SqlExecutionResult visitBinaryExpression(BinaryExpression node, ExecutionContext context) { return null; }</span>
<span class="nc" id="L1270">    @Override public SqlExecutionResult visitUnaryExpression(UnaryExpression node, ExecutionContext context) { return null; }</span>
<span class="nc" id="L1271">    @Override public SqlExecutionResult visitFunctionCall(FunctionCall node, ExecutionContext context) { return null; }</span>
<span class="nc" id="L1272">    @Override public SqlExecutionResult visitCaseExpression(CaseExpression node, ExecutionContext context) { return null; }</span>
<span class="nc" id="L1273">    @Override public SqlExecutionResult visitFromClause(FromClause node, ExecutionContext context) { return null; }</span>
<span class="nc" id="L1274">    @Override public SqlExecutionResult visitWhereClause(WhereClause node, ExecutionContext context) { return null; }</span>
<span class="nc" id="L1275">    @Override public SqlExecutionResult visitOrderByClause(OrderByClause node, ExecutionContext context) { return null; }</span>
<span class="nc" id="L1276">    @Override public SqlExecutionResult visitGroupByClause(GroupByClause node, ExecutionContext context) { return null; }</span>
<span class="nc" id="L1277">    @Override public SqlExecutionResult visitHavingClause(HavingClause node, ExecutionContext context) { return null; }</span>
<span class="nc" id="L1278">    @Override public SqlExecutionResult visitLimitClause(LimitClause node, ExecutionContext context) { return null; }</span>
<span class="nc" id="L1279">    @Override public SqlExecutionResult visitTableReference(TableReference node, ExecutionContext context) { return null; }</span>
<span class="nc" id="L1280">    @Override public SqlExecutionResult visitJoinClause(JoinClause node, ExecutionContext context) { return null; }</span>
<span class="nc" id="L1281">    @Override public SqlExecutionResult visitSelectItem(SelectItem node, ExecutionContext context) { return null; }</span>
<span class="nc" id="L1282">    @Override public SqlExecutionResult visitDataType(DataTypeNode node, ExecutionContext context) { return null; }</span>
<span class="nc" id="L1283">    @Override public SqlExecutionResult visitColumnDefinition(ColumnDefinition node, ExecutionContext context) { return null; }</span>
<span class="nc" id="L1284">    @Override public SqlExecutionResult visitSubqueryExpression(SubqueryExpression node, ExecutionContext context) { return null; }</span>
<span class="nc" id="L1285">    @Override public SqlExecutionResult visitExistsExpression(ExistsExpression node, ExecutionContext context) { return null; }</span>
<span class="nc" id="L1286">    @Override public SqlExecutionResult visitInSubqueryExpression(InSubqueryExpression node, ExecutionContext context) { return null; }</span>
<span class="nc" id="L1287">    @Override public SqlExecutionResult visitAggregateFunction(AggregateFunction node, ExecutionContext context) { return null; }</span>
    
    // Helper methods for aggregation
    private boolean hasAggregateFunction(List&lt;SelectItem&gt; selectItems) {
<span class="fc bfc" id="L1291" title="All 2 branches covered.">        for (SelectItem item : selectItems) {</span>
<span class="fc bfc" id="L1292" title="All 2 branches covered.">            if (containsAggregateFunction(item.getExpression())) {</span>
<span class="fc" id="L1293">                return true;</span>
            }
<span class="fc" id="L1295">        }</span>
<span class="fc" id="L1296">        return false;</span>
    }
    
    private boolean containsAggregateFunction(Expression expression) {
<span class="fc bfc" id="L1300" title="All 2 branches covered.">        if (expression instanceof AggregateFunction) {</span>
<span class="fc" id="L1301">            return true;</span>
        }
        // TODO: Recursively check nested expressions
<span class="fc" id="L1304">        return false;</span>
    }
    
    private static class AggregationResult {
        final List&lt;Column&gt; columns;
        final List&lt;Row&gt; rows;
        
<span class="fc" id="L1311">        AggregationResult(List&lt;Column&gt; columns, List&lt;Row&gt; rows) {</span>
<span class="fc" id="L1312">            this.columns = columns;</span>
<span class="fc" id="L1313">            this.rows = rows;</span>
<span class="fc" id="L1314">        }</span>
    }
    
    private AggregationResult performAggregation(SelectStatement selectStatement, List&lt;Row&gt; rows, 
                                                List&lt;Column&gt; columns, ExecutionContext context) throws SqlExecutionException {
        
        // If there's a GROUP BY clause, group the rows
<span class="fc bfc" id="L1321" title="All 2 branches covered.">        if (selectStatement.getGroupByClause().isPresent()) {</span>
<span class="fc" id="L1322">            return performGroupByAggregation(selectStatement, rows, columns, context);</span>
        } else {
            // Simple aggregation without grouping - treat all rows as one group
<span class="fc" id="L1325">            return performSimpleAggregation(selectStatement, rows, columns, context);</span>
        }
    }
    
    private AggregationResult performSimpleAggregation(SelectStatement selectStatement, List&lt;Row&gt; rows, 
                                                      List&lt;Column&gt; columns, ExecutionContext context) throws SqlExecutionException {
        
        // Calculate aggregate values for all rows as a single group
<span class="fc" id="L1333">        List&lt;Object&gt; aggregatedValues = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1334">        List&lt;Column&gt; resultColumns = new ArrayList&lt;&gt;();</span>
        
<span class="fc bfc" id="L1336" title="All 2 branches covered.">        for (int i = 0; i &lt; selectStatement.getSelectItems().size(); i++) {</span>
<span class="fc" id="L1337">            SelectItem item = selectStatement.getSelectItems().get(i);</span>
            String columnName;
<span class="fc bfc" id="L1339" title="All 2 branches covered.">            if (item.getAlias().isPresent()) {</span>
<span class="fc" id="L1340">                columnName = item.getAlias().get();</span>
<span class="pc bpc" id="L1341" title="1 of 2 branches missed.">            } else if (item.getExpression() instanceof com.memgres.sql.ast.expression.ColumnReference) {</span>
<span class="nc" id="L1342">                com.memgres.sql.ast.expression.ColumnReference colRef = </span>
<span class="nc" id="L1343">                    (com.memgres.sql.ast.expression.ColumnReference) item.getExpression();</span>
<span class="nc" id="L1344">                columnName = colRef.getColumnName();</span>
<span class="nc" id="L1345">            } else {</span>
<span class="fc" id="L1346">                columnName = &quot;column&quot; + i;</span>
            }
            
<span class="pc bpc" id="L1349" title="1 of 2 branches missed.">            if (item.getExpression() instanceof AggregateFunction) {</span>
<span class="fc" id="L1350">                AggregateFunction aggregateFunc = (AggregateFunction) item.getExpression();</span>
<span class="fc" id="L1351">                Object aggregatedValue = calculateAggregateValue(aggregateFunc, rows, columns, context);</span>
<span class="fc" id="L1352">                aggregatedValues.add(aggregatedValue);</span>
<span class="fc" id="L1353">            } else {</span>
                // Non-aggregate expression in aggregate query - use first row's value
<span class="nc bnc" id="L1355" title="All 2 branches missed.">                if (!rows.isEmpty()) {</span>
<span class="nc" id="L1356">                    context.setCurrentRow(rows.get(0));</span>
<span class="nc" id="L1357">                    context.setJoinedColumns(columns);</span>
<span class="nc" id="L1358">                    Object value = expressionEvaluator.evaluate(item.getExpression(), context);</span>
<span class="nc" id="L1359">                    aggregatedValues.add(value);</span>
<span class="nc" id="L1360">                } else {</span>
<span class="nc" id="L1361">                    aggregatedValues.add(null);</span>
                }
            }
            
<span class="fc" id="L1365">            resultColumns.add(new Column.Builder()</span>
<span class="fc" id="L1366">                .name(columnName)</span>
<span class="fc" id="L1367">                .dataType(DataType.TEXT)</span>
<span class="fc" id="L1368">                .build());</span>
        }
        
<span class="fc" id="L1371">        Row resultRow = new Row(1L, aggregatedValues.toArray());</span>
<span class="fc" id="L1372">        return new AggregationResult(resultColumns, List.of(resultRow));</span>
    }
    
    private AggregationResult performGroupByAggregation(SelectStatement selectStatement, List&lt;Row&gt; rows, 
                                                       List&lt;Column&gt; columns, ExecutionContext context) throws SqlExecutionException {
        
<span class="fc" id="L1378">        GroupByClause groupBy = selectStatement.getGroupByClause().get();</span>
        
        // Group rows by GROUP BY expressions
<span class="fc" id="L1381">        Map&lt;String, List&lt;Row&gt;&gt; groups = new LinkedHashMap&lt;&gt;();</span>
        
<span class="fc bfc" id="L1383" title="All 2 branches covered.">        for (Row row : rows) {</span>
<span class="fc" id="L1384">            context.setCurrentRow(row);</span>
<span class="fc" id="L1385">            context.setJoinedColumns(columns);</span>
            
            // Calculate group key
<span class="fc" id="L1388">            StringBuilder keyBuilder = new StringBuilder();</span>
<span class="fc bfc" id="L1389" title="All 2 branches covered.">            for (int i = 0; i &lt; groupBy.getGroupingExpressions().size(); i++) {</span>
<span class="fc" id="L1390">                Expression groupExpr = groupBy.getGroupingExpressions().get(i);</span>
<span class="fc" id="L1391">                Object value = expressionEvaluator.evaluate(groupExpr, context);</span>
<span class="fc bfc" id="L1392" title="All 2 branches covered.">                if (i &gt; 0) keyBuilder.append(&quot;|&quot;);</span>
<span class="pc bpc" id="L1393" title="1 of 2 branches missed.">                keyBuilder.append(value != null ? value.toString() : &quot;NULL&quot;);</span>
            }
<span class="fc" id="L1395">            String groupKey = keyBuilder.toString();</span>
            
<span class="fc" id="L1397">            groups.computeIfAbsent(groupKey, k -&gt; new ArrayList&lt;&gt;()).add(row);</span>
<span class="fc" id="L1398">        }</span>
        
        // Calculate aggregated results for each group
<span class="fc" id="L1401">        List&lt;Row&gt; resultRows = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1402">        List&lt;Column&gt; resultColumns = new ArrayList&lt;&gt;();</span>
        
        // Determine result columns
<span class="fc bfc" id="L1405" title="All 2 branches covered.">        for (int i = 0; i &lt; selectStatement.getSelectItems().size(); i++) {</span>
<span class="fc" id="L1406">            SelectItem item = selectStatement.getSelectItems().get(i);</span>
            String columnName;
<span class="fc bfc" id="L1408" title="All 2 branches covered.">            if (item.getAlias().isPresent()) {</span>
<span class="fc" id="L1409">                columnName = item.getAlias().get();</span>
<span class="pc bpc" id="L1410" title="1 of 2 branches missed.">            } else if (item.getExpression() instanceof com.memgres.sql.ast.expression.ColumnReference) {</span>
<span class="fc" id="L1411">                com.memgres.sql.ast.expression.ColumnReference colRef = </span>
<span class="fc" id="L1412">                    (com.memgres.sql.ast.expression.ColumnReference) item.getExpression();</span>
<span class="fc" id="L1413">                columnName = colRef.getColumnName();</span>
<span class="fc" id="L1414">            } else {</span>
<span class="nc" id="L1415">                columnName = &quot;column&quot; + i;</span>
            }
<span class="fc" id="L1417">            resultColumns.add(new Column.Builder()</span>
<span class="fc" id="L1418">                .name(columnName)</span>
<span class="fc" id="L1419">                .dataType(DataType.TEXT)</span>
<span class="fc" id="L1420">                .build());</span>
        }
        
        // Process each group
<span class="fc" id="L1424">        long rowId = 1;</span>
<span class="fc bfc" id="L1425" title="All 2 branches covered.">        for (Map.Entry&lt;String, List&lt;Row&gt;&gt; group : groups.entrySet()) {</span>
<span class="fc" id="L1426">            List&lt;Row&gt; groupRows = group.getValue();</span>
<span class="fc" id="L1427">            List&lt;Object&gt; aggregatedValues = new ArrayList&lt;&gt;();</span>
            
<span class="fc bfc" id="L1429" title="All 2 branches covered.">            for (SelectItem item : selectStatement.getSelectItems()) {</span>
<span class="fc bfc" id="L1430" title="All 2 branches covered.">                if (item.getExpression() instanceof AggregateFunction) {</span>
<span class="fc" id="L1431">                    AggregateFunction aggregateFunc = (AggregateFunction) item.getExpression();</span>
<span class="fc" id="L1432">                    Object aggregatedValue = calculateAggregateValue(aggregateFunc, groupRows, columns, context);</span>
<span class="fc" id="L1433">                    aggregatedValues.add(aggregatedValue);</span>
<span class="fc" id="L1434">                } else {</span>
                    // Non-aggregate expression in GROUP BY query - use first row's value
<span class="pc bpc" id="L1436" title="1 of 2 branches missed.">                    if (!groupRows.isEmpty()) {</span>
<span class="fc" id="L1437">                        context.setCurrentRow(groupRows.get(0));</span>
<span class="fc" id="L1438">                        context.setJoinedColumns(columns);</span>
<span class="fc" id="L1439">                        Object value = expressionEvaluator.evaluate(item.getExpression(), context);</span>
<span class="fc" id="L1440">                        aggregatedValues.add(value);</span>
<span class="fc" id="L1441">                    } else {</span>
<span class="nc" id="L1442">                        aggregatedValues.add(null);</span>
                    }
                }
<span class="fc" id="L1445">            }</span>
            
<span class="fc" id="L1447">            Row resultRow = new Row(rowId++, aggregatedValues.toArray());</span>
<span class="fc" id="L1448">            resultRows.add(resultRow);</span>
<span class="fc" id="L1449">        }</span>
        
<span class="fc" id="L1451">        return new AggregationResult(resultColumns, resultRows);</span>
    }
    
    private Object calculateAggregateValue(AggregateFunction aggregateFunc, List&lt;Row&gt; rows, 
                                          List&lt;Column&gt; columns, ExecutionContext context) {
        
<span class="pc bpc" id="L1457" title="2 of 7 branches missed.">        switch (aggregateFunc.getAggregateType()) {</span>
            case COUNT:
<span class="fc bfc" id="L1459" title="All 2 branches covered.">                if (aggregateFunc.isCountStar()) {</span>
<span class="fc" id="L1460">                    return (long) rows.size();</span>
                } else {
                    // COUNT with expression - count non-null values
<span class="fc" id="L1463">                    long count = 0;</span>
<span class="fc bfc" id="L1464" title="All 2 branches covered.">                    for (Row row : rows) {</span>
<span class="fc" id="L1465">                        context.setCurrentRow(row);</span>
<span class="fc" id="L1466">                        context.setJoinedColumns(columns);</span>
<span class="fc" id="L1467">                        Object value = expressionEvaluator.evaluate(aggregateFunc.getExpression(), context);</span>
<span class="pc bpc" id="L1468" title="1 of 2 branches missed.">                        if (value != null) {</span>
<span class="fc" id="L1469">                            count++;</span>
                        }
<span class="fc" id="L1471">                    }</span>
<span class="fc" id="L1472">                    return count;</span>
                }
                
            case COUNT_DISTINCT:
                // COUNT DISTINCT - count unique non-null values
<span class="nc" id="L1477">                Set&lt;Object&gt; uniqueValues = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L1478" title="All 2 branches missed.">                for (Row row : rows) {</span>
<span class="nc" id="L1479">                    context.setCurrentRow(row);</span>
<span class="nc" id="L1480">                    context.setJoinedColumns(columns);</span>
<span class="nc" id="L1481">                    Object value = expressionEvaluator.evaluate(aggregateFunc.getExpression(), context);</span>
<span class="nc bnc" id="L1482" title="All 2 branches missed.">                    if (value != null) {</span>
<span class="nc" id="L1483">                        uniqueValues.add(value);</span>
                    }
<span class="nc" id="L1485">                }</span>
<span class="nc" id="L1486">                return (long) uniqueValues.size();</span>
                
            case SUM:
                // SUM - sum numeric values
<span class="fc" id="L1490">                double sum = 0;</span>
<span class="fc bfc" id="L1491" title="All 2 branches covered.">                for (Row row : rows) {</span>
<span class="fc" id="L1492">                    context.setCurrentRow(row);</span>
<span class="fc" id="L1493">                    context.setJoinedColumns(columns);</span>
<span class="fc" id="L1494">                    Object value = expressionEvaluator.evaluate(aggregateFunc.getExpression(), context);</span>
<span class="pc bpc" id="L1495" title="1 of 2 branches missed.">                    if (value instanceof Number) {</span>
<span class="fc" id="L1496">                        sum += ((Number) value).doubleValue();</span>
                    }
<span class="fc" id="L1498">                }</span>
<span class="fc" id="L1499">                return sum;</span>
                
            case AVG:
                // AVG - average of numeric values
<span class="fc" id="L1503">                double total = 0;</span>
<span class="fc" id="L1504">                int count = 0;</span>
<span class="fc bfc" id="L1505" title="All 2 branches covered.">                for (Row row : rows) {</span>
<span class="fc" id="L1506">                    context.setCurrentRow(row);</span>
<span class="fc" id="L1507">                    context.setJoinedColumns(columns);</span>
<span class="fc" id="L1508">                    Object value = expressionEvaluator.evaluate(aggregateFunc.getExpression(), context);</span>
<span class="pc bpc" id="L1509" title="1 of 2 branches missed.">                    if (value instanceof Number) {</span>
<span class="fc" id="L1510">                        total += ((Number) value).doubleValue();</span>
<span class="fc" id="L1511">                        count++;</span>
                    }
<span class="fc" id="L1513">                }</span>
<span class="pc bpc" id="L1514" title="1 of 2 branches missed.">                return count &gt; 0 ? total / count : null;</span>
                
            case MIN:
                // MIN - minimum value
<span class="fc" id="L1518">                Object min = null;</span>
<span class="fc bfc" id="L1519" title="All 2 branches covered.">                for (Row row : rows) {</span>
<span class="fc" id="L1520">                    context.setCurrentRow(row);</span>
<span class="fc" id="L1521">                    context.setJoinedColumns(columns);</span>
<span class="fc" id="L1522">                    Object value = expressionEvaluator.evaluate(aggregateFunc.getExpression(), context);</span>
<span class="pc bpc" id="L1523" title="1 of 2 branches missed.">                    if (value != null) {</span>
<span class="pc bpc" id="L1524" title="1 of 4 branches missed.">                        if (min == null || compareObjects(value, min) &lt; 0) {</span>
<span class="fc" id="L1525">                            min = value;</span>
                        }
                    }
<span class="fc" id="L1528">                }</span>
<span class="fc" id="L1529">                return min;</span>
                
            case MAX:
                // MAX - maximum value
<span class="fc" id="L1533">                Object max = null;</span>
<span class="fc bfc" id="L1534" title="All 2 branches covered.">                for (Row row : rows) {</span>
<span class="fc" id="L1535">                    context.setCurrentRow(row);</span>
<span class="fc" id="L1536">                    context.setJoinedColumns(columns);</span>
<span class="fc" id="L1537">                    Object value = expressionEvaluator.evaluate(aggregateFunc.getExpression(), context);</span>
<span class="pc bpc" id="L1538" title="1 of 2 branches missed.">                    if (value != null) {</span>
<span class="pc bpc" id="L1539" title="1 of 4 branches missed.">                        if (max == null || compareObjects(value, max) &gt; 0) {</span>
<span class="fc" id="L1540">                            max = value;</span>
                        }
                    }
<span class="fc" id="L1543">                }</span>
<span class="fc" id="L1544">                return max;</span>
                
            default:
<span class="nc" id="L1547">                throw new IllegalArgumentException(&quot;Unsupported aggregate function: &quot; + aggregateFunc.getAggregateType());</span>
        }
    }
    
    @SuppressWarnings(&quot;unchecked&quot;)
    private int compareObjects(Object a, Object b) {
<span class="pc bpc" id="L1553" title="2 of 4 branches missed.">        if (a instanceof Comparable &amp;&amp; b instanceof Comparable) {</span>
            try {
<span class="fc" id="L1555">                return ((Comparable) a).compareTo(b);</span>
<span class="nc" id="L1556">            } catch (ClassCastException e) {</span>
<span class="nc" id="L1557">                return a.toString().compareTo(b.toString());</span>
            }
        }
<span class="nc" id="L1560">        return a.toString().compareTo(b.toString());</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>